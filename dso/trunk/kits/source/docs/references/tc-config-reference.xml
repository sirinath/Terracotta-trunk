<?xml version="1.0" encoding="UTF-8" ?>
<!--

  All content copyright (c) 2003-2006 Terracotta, Inc.,
  except as may otherwise be noted in a separate copyright notice.
  All rights reserved.

-->
<!--
  tc-config-reference.xml
  
  This is a sample Terracotta configuration file. In it, you will find an
  example of every permitted element, along with a brief description of each.
  As such, it's a good reference, but vastly more than you need to get started.
  Very few of the elements in this configuration file are required; they are
  marked with a (REQUIRED) notation.
-->
<tc:tc-config xmlns:tc="http://www.terracotta.org/config"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.terracotta.org/schema/terracotta-3.xsd">

  <!-- The 'system' section contains configuration data that affects the
     entire Terracotta system as a whole; things like whether to activate
     DSO services go here. -->
  
  <system>
    <!-- The configuration model: 'development' or 'production'.
    
       In 'development' mode, each client can have its own configuration,
       independent of the server or any other client. This mode can result in
       shared data being corrupted or lost if, for instance, two different
       clients specify roots of different types.

       In 'production' mode, it is enforced that each client has obtained its
       configuration from its server. When a client first connects to a server
       it determines the servers configuration model and, if production, ensures
       that its configuration source was that server. A client can specify that its
       configuration come from server by setting the 'tc.config' system propery as
       -Dtc.config=serverHost:dsoPort.

       Default: 'development'. -->
    <configuration-model>development</configuration-model>
  </system>

  <!--
    This section defines the servers present in your Terracotta system. You can
    omit this section entirely, in which case it behaves as if there's a
    single server with all values set at their default. You can include exactly
    one server entry here (the common case), or, if you're going to run multiple
    servers for failover, you can include multiple servers here.

    If you include more than one server here, note that each server will need to know
    which configuration it should use as it starts up. If you name your servers
    according to the host that they run on (and no host contains more than
    one server), then they will find the hostname themselves and work
    automatically.

    If you name your servers in any other fashion (and, again, only if there is
    more than one 'server' element present here), then you will need to pass the
    command-line option "-n <name>" to the start-tc-server script, passing it
    the name of a server configuration from this file.
  -->
  <servers>

    <!-- The host and symbolic name of the server; host defaults to "%i" (the machine's
         IP address) and name defaults to "host:dso-port".  Expansion parameters may be
         used in both attributes. -->
    <server host="artichoke" name="apple">

      <!-- Where should the server store its persistent data? (This includes
         stored object data for DSO.) This value undergoes parameter substitution
         before being used; this allows you to use placeholders like '%h' (for the hostname)
         or '%(com.mycompany.propname)' (to substitute in the value of
         Java system property 'com.mycompany.propname'). Thus, a value
         of 'server-data-%h' would expand to 'server-data-artichoke' if 
         running on host 'artichoke'. See the Product Guide for more
         details.

         If this is a relative path, then it is interpreted relative to
         the current working directory of the server (that is, the directory
         you were in when you started the server). It is thus recommended that
         you specify an absolute path here.

         Default: 'data'; this places the 'data' directory in the
         directory you were in when you invoked 'start-tc-server'.
      -->
      <data>/opt/terracotta/server-data</data>

      <!-- In which directory should the server store its log files? Again,
         this value undergoes parameter substitution before being used;
         thus, a value like 'server-logs-%h' would expand to
         'server-logs-artichoke' if running on host 'artichoke'. See the
         Product Guide for more details.

         If this is a relative path, then it is interpreted relative to
         the current working directory of the server (that is, the directory
         you were in when you started server). It is thus recommended that
         you specify an absolute path here.

         Default: 'logs'; this places the 'logs' directory in the
         directory you were in when you invoked 'start-tc-server'.
      -->
      <logs>/opt/terracotta/server-logs</logs>

      <!-- On what port should the DSO server listen for connections from DSO
         clients? This can be any port you like, but note that
         ports below 1024 typically require 'root' privileges to use
         on Un*x-style systems (Linux, Solaris).

         Default: 9510
      -->
      <dso-port>9510</dso-port>

      <!-- Configuration data for DSO that's specific to the DSO server. -->
      <dso>

        <!-- How much time should DSO server, upon restart, allow for previously
             connected clients to reconnect?  After this period, clients will
             not be allowed to reconnect.

             Default: 120 seconds
        --> 
        <client-reconnect-window>120</client-reconnect-window>
      
        <!-- Information about how DSO should persist data to disk. -->
        <persistence>
          <!-- How should DSO persist data to disk? This can be one
             of two values:
             
             'temporary-swap-only' causes the DSO server to use the
             disk as a temporary backing store. Data is not
             preserved across server restarts. This mode is somewhat
             faster than 'permanent-store' mode.
             
             'permanent-store' causes the DSO server to write data
             immediately and permanently to disk. Upon server restart,
             data will be restored, meaning data underneath roots
             in your program will be restored to the exact state it
             was in when the server shut down.
             
             Note that if you are using clustered DSO servers (i.e., if
             you have more than one <server> element defined,
             below), then you must use 'permanent-store' mode. This
             is required for proper operation of the DSO
             failover mechanism.
             
             Default: 'temporary-swap-only'
          -->
          <mode>permanent-store</mode>
        </persistence>
        
        <!-- Information about how DSO should perform distributed
           garbage collection on the data underneath your
           application's roots. -->
        <garbage-collection>
        
          <!-- If 'true', distributed garbage collection is enabled.
             You should only set this to 'false' if you are
             absolutely certain that none of the data underneath
             your roots will ever become garbage; certain 
             applications, such as those that read a large amount
             of data into a Map and never remove it (merely look up
             values in it) can safely do this.
             
             Default: true
          -->
          <enabled>true</enabled>
          
          <!-- If 'true', the DSO server will emit extra information when
             it performs distributed garbage collection; this can
             be useful when trying to performance-tune your
             application.
             
             Default: false
          -->
          <verbose>false</verbose>
          
          <!-- How often should the DSO server perform distributed 
             garbage collection, in seconds?
             
             Default: 3600 (60 minutes)
          -->
          <interval>3600</interval>
        </garbage-collection>
        
      </dso>
    </server>
    
    <server host="broccoli">
      <data>/usr/local/tc/data</data>
      <logs>/usr/local/tc/logs</logs>
      
      <dso-port>8510</dso-port>
      
      <dso>
        <persistence>
          <mode>permanent-store</mode>
        </persistence>
        
        <garbage-collection>
          <enabled>true</enabled>
          <verbose>true</verbose>
          <interval>3600</interval>
        </garbage-collection>
      </dso>
    </server>
  </servers>
  
  <!-- This section contains settings that affect all clients that connect to the
     system.
     
     Note that while these settings are applied uniformly across all clients,
     this does not prevent you from applying different settings to various
     clients. There are two ways of doing this:
     
      - Certain parameters ('logs', below) undergo parameter expansion
        before being used by the client. This allows you to use various predefined
        substitutions (like '%h' for host), or a general one
        (%(myprop) to use the value of Java system property 'myprop'), for
        these values; expansions are carried out in each client's JVM
        independently.  Parameter expansion is not done for values inside the
        <modules> element.
  -->
  <clients>

    <!--
        This section lists any modules (currently pre-defined configurations)
        for products you will be using.  These do not include the products themselves
        (you must provide that) but rather configuration information for Terracotta
        that describes what should be clustered.  Please check the 'modules'
        directory in the Terracotta installation directory for a list of
        supplied modules.

        The <modules> section is optional.
    -->
    <modules>

      <!--
        The 'modules' directory in the Terracotta installation directory is implied
        as the first reposository, however if you have other places to look for modules
        you can optionally specify as many of them as you wish here; they can be any
        valid URL.  Repositories are searched in the order defined here (after the
        implicit repository) for modules by appending
        "/<module-name>-<module-version>.jar" to each URL.  The first match succeeds.

        The <repository> element(s) is optional.
      -->
      <repository>file:///my/modules/directory</repository>
      <repository>http:///my/modules/webserver</repository>

      <!--
        If you choose to use a module, define it here.  Distributed modules have the
        file name "name-version.jar" where "name" and "version" are the <module>
        element attributes.  You may define 0 or more modules to be used, they are
        loaded in the order defined here.

        The <module> element(s) is optional.
      -->
      <module name="clustered-apache-struts" version="1.1"/>
      <module name="clustered-commons-collections" version="3.1"/>

    </modules>

    <!-- Where should the client write its log files?
    
       This value undergoes parameter substitution before being used;
       thus, a value like 'client-logs-%h' would expand to
       'client-logs-banana' if running on host 'banana'. See the
       Product Guide for more details.
    
       If this is a relative path, then it is interpreted relative to
       the current working directory of the client (that is, the directory
       you were in when you started the program that uses Terracotta
       services). It is thus recommended that you specify an absolute
       path here.
       
         
       Default: 'logs-%i'; this places the logs in a directory relative
       to the directory you were in when you invoked the program that uses
       Terracotta services (your client), and calls that directory, for example,
       'logs-10.0.0.57' if the machine that the client is on has assigned IP
       address 10.0.0.57.
    -->
    <logs>logs-%i</logs>
    
    <!-- This section contains data for Terracotta DSO that's specific to
       the DSO client only. -->
    <dso>
    
      <!-- This section controls output from the DSO client that can help you
         debug your program. -->
      <debugging>
      
        <!-- This section controls output from the DSO client related to
           class instrumentation. See the Product Guide for more
           details; each individual element controls a different kind
           of output. -->
           
        <instrumentation-logging>
          <class>false</class>
          <locks>false</locks>
          <transient-root>true</transient-root>
          <roots>false</roots>
          <distributed-methods>false</distributed-methods>
        </instrumentation-logging>
        
        <!-- This section controls output from the DSO client related to
           operations occurring at runtime. See the Product Guide for
           more details; each individual element controls a different
           kind of output. -->
           
        <runtime-logging>
          <non-portable-dump>true</non-portable-dump>
          <lock-debug>false</lock-debug>
          <wait-notify-debug>false</wait-notify-debug>
          <distributed-method-debug>false</distributed-method-debug>
          <new-object-debug>false</new-object-debug>
        </runtime-logging>
        
        <!-- This section controls the exact format of the output from
           any options enabled under 'runtime-logging', above. See
           the Product Guide for more details; each individual element
           controls a different kind of output. -->

        <runtime-output-options>
          <auto-lock-details>false</auto-lock-details>
          <caller>false</caller>
          <full-stack>false</full-stack>
        </runtime-output-options>
      </debugging>
    </dso>
  </clients>
  
  <!-- This section contains items that affect the core behavior of Terracotta
     as it relates to your application. This data must be kept consistent
     across clients and servers in order for Terracotta to function properly, and
     so the system will enforce this; see the comments for the
     'configuration-model' switch, above, for more details. -->
  <application>
  
    <!-- This section controls how Terracotta DSO behaves in your application. -->
    <dso>
    
      <!-- This section controls which classes are instrumented by
         Terracotta DSO. In order for an object to be shared among
         JVMs by DSO, or contain a root, its class must be instrumented.
         
         You can define 'include' and 'exclude' patterns here; 'exclude'
         patterns take precedence over 'include'. In other words, for
         a class to be instrumented, it must match at least one 'include'
         pattern and no 'exclude' patterns.
         
         Patterns here are AspectWerkz-compatible class specification
         expressions; see the Product Guide for details.
         
         Default: none; no classes are instrumented. Thus for proper
         DSO functionality, you must specify at least one 'include'
         section here.
      -->
      <instrumented-classes>
        <!-- This includes a certain set of classes for instrumentation. -->
        <include>
          <!-- The class(es) to include, as an AspectWerkz-compatible
             class specification expression. See the Product Guide
             for more details. (REQUIRED) -->
          <class-expression>com.mycompany.pkga.*</class-expression>
          
          <!-- If set to 'true', then any fields in the given class(es)
             that have the Java 'transient' modifier are not shared
             across JVMs. If set to 'false', they are.
             
             Default: false -->
          <honor-transient>true</honor-transient>
          <on-load>
            <!--This method will be called on instances of the specified class
                on load of the object. Used to rewire transients. -->
                  <!--<method>aMethod</method>-->

            <!-- This bean shell script is called right after an object is loaded -->
                  <execute><![CDATA[self.myTransientField = new ArrayList();]]></execute>
              </on-load>  
        </include>
        
        <!-- The class(es) to exclude, as an AspectWerkz-compatible
           class specification expression. See the Product Guide for
           more details. -->
        <exclude>com.mycompany.pkga.subpkg.*</exclude>
        
        <include>
          <class-expression>com.mycompany.pkgb.*</class-expression>
        </include>
      </instrumented-classes>
      
      <!-- This section lets you specify certain fields as 'transient' to
         Terracotta DSO. Note that this does not cause these fields
         to behave as 'transient' for Java serialization; rather, it
         simply means that the contents of these fields are not shared
         across JVMs by DSO.
         
         The expressions in 'field-name' are AspectWerkz-compatible
         field specification expressions. See the Product Guide for
         more details.
         
         Default: no extra fields are specified as 'transient' -->
      <transient-fields>
        <field-name>com.mycompany.pkga.MyClassOne.fieldA</field-name>
        <field-name>com.mycompany.pkgb.subpkg2.fieldB</field-name>
      </transient-fields>
      
      <!-- This section lets you specify locks to Terracotta DSO. Locks
         are critical to correct functioning of DSO. In general, see the
         Product Guide for more details.
         
         Two types of lock elements may be included here, in any order:
         'autolock' and 'named-lock'. Autolocks extend normal Java
         'synchronized' blocks across the entire cluster just as you'd
         expect, by locking on the object you're synchronizing upon;
         named locks are completely independent of Java synchronization.
         Named locks create a lock with the name specified below; no
         more than one thread in one VM, cluster-wide, can be inside
         any method protected by a lock with a given name at one time.
         See the Product Guide for more details.
      -->
      <locks>
        <!-- Specifies an autolock. -->
        <autolock>
          <!-- The expression of method(s) to lock. This is an
             AspectWerkz-compatible method specification expression.
             See the Product Guide for more details. (REQUIRED) -->
          <method-expression>* com.mycompany.pkga.MyClassOne.set*(..)</method-expression>
          
          <!-- The level of the lock: 'read', 'write', or 'concurrent'.
          
             Read locks may be used only when the method(s) being
             locked do not actually modify the data in question;
             multiple threads in multiple JVMs may be inside a 
             read lock at the same time. However, if a thread is
             locked upon the same object but using a write lock,
             then any threads that require a read lock must wait
             until it has completed.
             
             Write locks are used when the method(s) being locked
             modify the data being protected. Only one thread in one
             JVM, cluster-wide, may be inside a write lock at once.
             Further, no threads may be inside a read lock on the
             same object while one thread is inside a write lock.
             
             Concurrent locks are a looser form of write lock, and
             should be used with caution. Multiple threads can be
             inside a concurrent lock at the same time, and can all
             write to the data; they will each see a consistent view
             of the data at all times (i.e., none will see 'partial'
             modifications made by another thread before it exits
             the locked synchronized block), but, if multiple
             threads are in the same block at once, only the changes
             made by the last thread to exit the block actually
             take effect. This is nondeterministic and thus is
             generally used only with considerable caution.
          -->
          <lock-level>write</lock-level>
        </autolock>
        
        <!-- Specifies a named lock. If you create multiple named-lock
           sections in this file that share the same name, they are
           the same lock, and will behave as such. -->
        <named-lock>
          <!-- The name of the lock. (REQUIRED) -->
          <lock-name>lockOne</lock-name>
          
          <!-- The expression of method(s) to lock. This is an
             AspectWerkz-compatible method specification expression.
             See the Product Guide for more details. (REQUIRED) -->
          <method-expression>* com.mycompany.pkgb.get*(int)</method-expression>
          
          <!-- The level of the lock: 'read', 'write', or 'concurrent'.
             See above for more details.
          -->
          <lock-level>read</lock-level>
        </named-lock>
      </locks>
      
      <!-- This section specifies the roots for Terracotta DSO. Roots
         are the 'share points' in DSO; they specify fields in a class,
         such that DSO will make sure every instance of every class
         in every VM always sees the same object in that field (and
         in all fields of that object, and in all fields of those
         objects, and so on; the transitive closure of this data is
         shared). 
         
         Roots are specified using the fully-qualified name of a
         field. They can optionally be given a name.
      -->
      <roots>
        <root>
          <!-- The name of the field to make a root. This must be
             the fully-qualified name of a field. (REQUIRED) -->
          <field-name>com.mycompany.pkgc.AnotherClass.field1</field-name>
          
          <!-- The name for this root. This is optional, but can
             help when debugging your system. -->
          <root-name>rootOne</root-name>
        </root>
        
        <root>
          <field-name>com.mycompany.pkgc.ClassTwo.field3</field-name>
          <root-name>rootTwo</root-name>
        </root>
      </roots>
      
      <!-- This section specifies methods to invoke in a distributed 
         fashion via Terracotta DSO. When a method matching one of the
         patterns here is invoked in one JVM, Terracotta DSO will 
         cause it to be invoked simultaneously in all JVMs throughout
         the Terracotta cluster. This is often used for 'event listener'
         methods (for example, those used by Swing), to make sure that
         all JVMs throughout the cluster are informed when a particular
         event occurs. -->
      <distributed-methods>
        <!-- An AspectWerkz-compatible method specification expression
           denoting which method(s) to distribute. -->
        <method-expression>void com.mycompany.pkga.MyClass.somethingHappened(String, int)</method-expression>
        <method-expression>String[] com.mycompany.pkgc.AnotherClass.eventOccurred(Boolean, Double)</method-expression>
        <!-- An optional attribute run-on-all-nodes (default value "true") 
           can be set to false to execute distributed only on those nodes
           that already have a reference to the object on which the method
           is called -->
        <method-expression run-on-all-nodes="false">String[] com.mycompany.pkgc.AnotherClass.eventOccurred(Boolean, Double)</method-expression>

      </distributed-methods>
      
      <!-- Classes that are part of the 'java.' hierarchy (in other words,
         those classes included with the JVM) are instrumented by
         Terracotta DSO in a special fashion. Specifically, they are
         instrumented and placed into a special "boot JAR", which is
         included on the Java boot-classpath (which is, in turn,
         a different thing from the normal Java classpath) by the 
         dso-java tool.
         
         This "boot JAR" can be rebuilt by the 'dso-make-boot-jar' tool
         included with the Terracotta distribution, and must be rebuilt
         when transitioning from one vendor's JVM to another, or between
         major releases of the JVM.
         
         Many commonly-used classes are included by default in the
         Terracotta boot JAR. However, if a class is not included by 
         default in the Terracotta boot JAR, then you can place its
         name here and specify this configuration file to the 
         'dso-make-boot-jar' tool; this will cause it to be included
         when the boot JAR is rebuilt. 
         
         Note that Terracotta cannot guarantee that all 'java.' classes
         can be safely added here, although many will work correctly.
         If in doubt, consult Terracotta for details.
         
         Default: no additional classes are included in the Terracotta
         boot JAR.
         -->
      <additional-boot-jar-classes>
        <include>java.awt.datatransfer.Clipboard</include>
      </additional-boot-jar-classes>
      
      <!-- When using Terracotta DSO within an application server, you
         must specify the names of the J2EE applications under which
         Terracotta DSO should operate. These must match the application
         names as you have defined them in your application server's
         configuration files, if you want to use Terracotta DSO in
         those applications. -->
      <web-applications>
        <web-application>petstore</web-application>
        <web-application>billing_app</web-application>
      </web-applications>
      
      <!-- When enabled, the default, mutations to shared objects made
         through reflection behave like normal shared object changes. When
         disabled, changes made to shared objects via reflection are not
         cluster-wide. -->
      <dso-reflection-enabled>true</dso-reflection-enabled>      
    </dso>
    
    <!-- This section is a self-contained configuration that controls how 
      Terracotta Spring behaves in your application. 
    -->
    <spring>
    
      <!-- "jee-application" specifies the Spring application(s) that will be
        potentially clustered/shared by Terracotta server; It is a required
        element with minimum 1 occurence and can be repeated unbounded times;
        Required attribute "name" is a pattern that will be matched against
        the Spring application name; The JEE application name is in most cases
        the name of the WAR, EAR or JAR file in which the Spring application
        resides.
        If you are using Spring in a stand-alone application then you can use
        "*" as the name. The pattern matching supports wildcards of leading
        and ending asterisk (*), which matches arbitrary number of characters;
        Example patterns include "*foo", "foo*" and "*foo*"; "*" and "**" are
        also legal, but NOT "fo*o"; The name of a Spring application is
        evaluated as the web application name - more accurately the context
        path pointing to the web application, if the Spring application was
        deployed in a Web application; otherwise, it is evaluated to an
        empty string. -->
       <jee-application name="name-of-jee-application">

         <!-- "fast-proxy" specifies a boolean indicator for using AspectWerkz
           AOP Proxy as an optional performance enhancement to Spring AOP
           ProxyFactoryBean; Default to false. -->
        <fast-proxy>false</fast-proxy>

        <!-- "session-support" specifies if HTTP session clustering should be
          enabled for given web application. Default to false. Can be used,
          for example, to cluster Spring WebFlow conversations. -->
        <session-support>false</session-support>

        <!-- "application-contexts" define configuration for clustering of
          Spring-managed beans for specific Spring application context. If
          bean clustering is not needed, element can be skipped. 
        -->
	  <application-contexts>
		
          <!-- Configuration for individual application context. Includes path
            to bean definition file (e.g. applicationContext.xml), list of
            beans and context events that should be clustered.
            Optional; Internally, each "application-context" matches one
            config helper instance. -->
          <application-context>
            
            <!-- Specifies the bean definition resource patterns; The matching
              applys OR logic for individual path element. Required. -->
            <paths>

              <!-- Specifies a bean definition resource location pattern;
                The pattern matching supports wildcards of leading and ending
                asterisk (*), which is the same algorithm as of the
                application name; Optional. -->
              <path>*/beanfactory1.xml</path>
              <path>*/beanfactory2.xml</path>
            </paths>
            
            <!-- Specifies list of clustered beans and their configuration for
              this application context. Spring beans with the same name in
              different contexts will be different logical beans. Required. -->
            <beans>

              <!-- Specifies a distributed bean; The bean name should be the
                same name that the bean has in the Spring bean config file.
                Matching has to be exact; Optional. -->
              <bean name="clusteredBeanOne">

                <!-- Specifies the names of non-distributed field references
                  within a Spring bean instance. They are used for identifying
                  the fields that need to maintain a local value (e.g. NOT be
                  shared/clustered). Be aware that the hosting bean could be
                  matched in multiple application context patterns, in which
                  case "AND" logic will be applied; for example if the same
                  bean is defined as shared/clustered in two different
                  application contexts and has a field that in one place is
                  defined as "non-distributed" but in the other place not
                  (e.g. shared), then the field reference will be
                  shared/clustered. -->
                <non-distributed-field>myFieldOne</non-distributed-field>
                <non-distributed-field>myFieldTwo</non-distributed-field>
              </bean>
              
              <bean name="clusteredBeanTwo"/>
            </beans>

            <!-- Specifies what event types published in this application
              context should be distributed to other cluster nodes (but still
              local within the same "logical" applicationcontext); Required. -->
            <distributed-events>

               <!-- Specifies the event classes, e.g. the type of the event;
                 The pattern matching supports wildcards of leading and ending
                 asterisk (*), which is the same as of the application name. -->
              <distributed-event>com.mycompany.pkgb.*</distributed-event>
            </distributed-events>
            
          </application-context>
        </application-contexts>
  
        <!-- This section lets you specify locks to Terracotta DSO. Locks
           are critical to correct functioning of DSO. In general, see the
           Product Guide for more details.

           Two types of lock elements may be included here, in any order:
           'autolock' and 'named-lock'. Autolocks extend normal Java
           'synchronized' blocks across the entire cluster just as you'd
           expect, by locking on the object you're synchronizing upon;
           named locks are completely independent of Java synchronization.
           Named locks create a lock with the name specified below; no
           more than one thread in one VM, cluster-wide, can be inside
           any method protected by a lock with a given name at one time.
           See the Product Guide for more details.
           This section is optional, and most of the time it does NOT present.
        -->
        <locks>
          <!-- Specifies an autolock. -->
          <autolock>
            <!-- The expression of method(s) to lock. This is an
               AspectWerkz-compatible method specification expression.
               See the Product Guide for more details. (REQUIRED) -->
            <method-expression>* com.mycompany.pkga.MyClassOne.set*(..)</method-expression>

            <!-- The level of the lock: 'read', 'write', or 'concurrent'.

               Read locks may be used only when the method(s) being
               locked do not actually modify the data in question;
               multiple threads in multiple JVMs may be inside a 
               read lock at the same time. However, if a thread is
               locked upon the same object but using a write lock,
               then any threads that require a read lock must wait
               until it has completed.

               Write locks are used when the method(s) being locked
               modify the data being protected. Only one thread in one
               JVM, cluster-wide, may be inside a write lock at once.
               Further, no threads may be inside a read lock on the
               same object while one thread is inside a write lock.

               Concurrent locks are a looser form of write lock, and
               should be used with caution. Multiple threads can be
               inside a concurrent lock at the same time, and can all
               write to the data; they will each see a consistent view
               of the data at all times (i.e., none will see 'partial'
               modifications made by another thread before it exits
               the locked synchronized block), but, if multiple
               threads are in the same block at once, only the changes
               made by the last thread to exit the block actually
               take effect. This is nondeterministic and thus is
               generally used only with considerable caution.
            -->
            <lock-level>write</lock-level>
          </autolock>

          <!-- Specifies a named lock. If you create multiple named-lock
             sections in this file that share the same name, they are
             the same lock, and will behave as such. -->
          <named-lock>
            <!-- The name of the lock. (REQUIRED) -->
            <lock-name>lockOne</lock-name>

            <!-- The expression of method(s) to lock. This is an
               AspectWerkz-compatible method specification expression.
               See the Product Guide for more details. (REQUIRED) -->
            <method-expression>* com.mycompany.pkgb.get*(int)</method-expression>

            <!-- The level of the lock: 'read', 'write', or 'concurrent'.
               See above for more details.
            -->
            <lock-level>read</lock-level>
          </named-lock>
        </locks>


        <!-- This section controls which classes are instrumented by
           Terracotta DSO. In order for an object to be shared among
           JVMs by DSO, or contain a root, its class must be instrumented.

           You can define 'include' and 'exclude' patterns here; 'exclude'
           patterns take precedence over 'include'. In other words, for
           a class to be instrumented, it must match at least one 'include'
           pattern and no 'exclude' patterns.

           Patterns here are AspectWerkz-compatible class specification
           expressions; see the Product Guide for details.

           Default: none; no classes are instrumented. Thus for proper
           DSO functionality, you must specify at least one 'include'
           section here.
           This section is optional, and most of the time it does not present.
        -->
        <instrumented-classes>
          <!-- This includes a certain set of classes for instrumentation. -->
          <include>
            <!-- The class(es) to include, as an AspectWerkz-compatible
               class specification expression. See the Product Guide
               for more details. (REQUIRED) -->
            <class-expression>com.mycompany.pkga.*</class-expression>

            <!-- If set to 'true', then any fields in the given class(es)
               that have the Java 'transient' modifier are not shared
               across JVMs. If set to 'false', they are.

               Default: false -->
            <honor-transient>true</honor-transient>
            <on-load>
              <!--This method will be called on instances of the specified class
                  on load of the object. Used to rewire transients. -->
              <!--<method>aMethod</method>-->

                <!-- This bean shell script is called right after an object is loaded -->
                <execute><![CDATA[self.myTransientField = new ArrayList();]]></execute>
              </on-load>  
          </include>

          <!-- The class(es) to exclude, as an AspectWerkz-compatible
             class specification expression. See the Product Guide for
             more details. -->
          <exclude>com.mycompany.pkga.subpkg.*</exclude>

          <include>
            <class-expression>com.mycompany.pkgb.*</class-expression>
          </include>
        </instrumented-classes>

      </jee-application>
    </spring>
    
  </application>
</tc:tc-config>
