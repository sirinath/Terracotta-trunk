/*
 * All content copyright (c) 2003-2008 Terracotta, Inc., except as may otherwise be noted in a separate copyright notice.  All rights reserved.
 */
package com.tc.object.bytecode;

import com.tc.asm.ClassAdapter;
import com.tc.asm.MethodAdapter;
import com.tc.asm.ClassVisitor;
import com.tc.asm.Label;
import com.tc.asm.MethodVisitor;
import com.tc.asm.Opcodes;
import com.tc.object.SerializationUtil;

public class JavaUtilConcurrentLinkedBlockingQueueClassAdapter extends ClassAdapter implements Opcodes {
  private static final String TC_TAKE_METHOD_NAME    = ByteCodeUtil.TC_METHOD_PREFIX + "take";
  private static final String TC_PUT_METHOD_NAME     = ByteCodeUtil.TC_METHOD_PREFIX + "put";
  private static final String TC_EXTRACT_METHOD_NAME = ByteCodeUtil.TC_METHOD_PREFIX + "extract";
  private static final String TC_EXTRACT_METHOD_DESC = "()Ljava/lang/Object;";

  private static final String GET_ITEM_METHOD_NAME   = "getItem";
  private static final String GET_ITEM_METHOD_DESC   = "()Ljava/lang/Object;";

  public JavaUtilConcurrentLinkedBlockingQueueClassAdapter(ClassVisitor cv) {
    super(cv);
  }

  public void visitEnd() {
    addTCExtractMethod();
    addTCTakeMethod();
    addTCPutMethod();
    addInitMethodCode();
    super.visitEnd();
  }

  public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
    MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);
    // Recreating these 4 methods because the instrumented code is very ad hoc.
    mv = new NodeMethodAdapter(mv);
    if ("remove".equals(name) && "(Ljava/lang/Object;)Z".equals(desc)) {
      recreateRemoveMethod(mv);
      return null;
    } else if ("offer".equals(name) && "(Ljava/lang/Object;)Z".equals(desc)) {
      recreateOfferMethod(mv);
      return null;
    } else if ("offer".equals(name) && "(Ljava/lang/Object;JLjava/util/concurrent/TimeUnit;)Z".equals(desc)) {
      recreateOfferTimeoutMethod(mv);
      return null;
    } else if ("put".equals(name) && "(Ljava/lang/Object;)V".equals(desc)) {
      recreatePutMethod(mv);
      return null;
    }
      

    return mv;
  }
  
  /*
   * The __tc_put() is a non-blocking version of put() and is called in the applicator only.
   * We allow it to go over the capacity of the LinkedBlockingQueue but the capacity should
   * eventually goes down by take() method in the application thread.
   */
  private void addTCPutMethod() {
    MethodVisitor mv = super.visitMethod(ACC_PUBLIC, TC_PUT_METHOD_NAME, "(Ljava/lang/Object;)V", null, new String[] { "java/lang/InterruptedException" });
    mv.visitCode();
    Label l0 = new Label();
    Label l1 = new Label();
    mv.visitTryCatchBlock(l0, l1, l1, null);
    Label l2 = new Label();
    Label l3 = new Label();
    mv.visitTryCatchBlock(l2, l3, l1, null);
    Label l4 = new Label();
    mv.visitLabel(l4);
    mv.visitVarInsn(ALOAD, 1);
    Label l5 = new Label();
    mv.visitJumpInsn(IFNONNULL, l5);
    mv.visitTypeInsn(NEW, "java/lang/NullPointerException");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL, "java/lang/NullPointerException", "<init>", "()V");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l5);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 2);
    Label l6 = new Label();
    mv.visitLabel(l6);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "putLock", "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitVarInsn(ASTORE, 3);
    Label l7 = new Label();
    mv.visitLabel(l7);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "count", "Ljava/util/concurrent/atomic/AtomicInteger;");
    mv.visitVarInsn(ASTORE, 4);
    Label l8 = new Label();
    mv.visitLabel(l8);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "lockInterruptibly", "()V");
    mv.visitLabel(l0);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "insert", "(Ljava/lang/Object;)V");
    Label l9 = new Label();
    mv.visitLabel(l9);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 2);
    Label l10 = new Label();
    mv.visitLabel(l10);
    mv.visitVarInsn(ILOAD, 2);
    mv.visitInsn(ICONST_1);
    mv.visitInsn(IADD);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    mv.visitJumpInsn(IF_ICMPGE, l2);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signal", "()V");
    mv.visitJumpInsn(GOTO, l2);
    mv.visitLabel(l1);
    mv.visitVarInsn(ASTORE, 6);
    Label l11 = new Label();
    mv.visitJumpInsn(JSR, l11);
    Label l12 = new Label();
    mv.visitLabel(l12);
    mv.visitVarInsn(ALOAD, 6);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l11);
    mv.visitVarInsn(ASTORE, 5);
    Label l13 = new Label();
    mv.visitLabel(l13);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l14 = new Label();
    mv.visitLabel(l14);
    mv.visitVarInsn(RET, 5);
    mv.visitLabel(l2);
    mv.visitJumpInsn(JSR, l11);
    mv.visitLabel(l3);
    mv.visitVarInsn(ILOAD, 2);
    Label l15 = new Label();
    mv.visitJumpInsn(IFNE, l15);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "signalNotEmpty", "()V");
    mv.visitLabel(l15);
    mv.visitInsn(RETURN);
    Label l16 = new Label();
    mv.visitLabel(l16);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
  }

  /**
   * The __tc_take() method is the non-blocking version of take and is used by the applicator
   * only. We allow the capacity to fall below 0, but the capacity should eventually goes up
   * by the put() method in the application thread.
   */
  private void addTCTakeMethod() {
    MethodVisitor mv = super.visitMethod(ACC_PUBLIC, TC_TAKE_METHOD_NAME, "()Ljava/lang/Object;", null,
                                         new String[] { "java/lang/InterruptedException" });
    mv.visitCode();
    Label l0 = new Label();
    Label l1 = new Label();
    mv.visitTryCatchBlock(l0, l1, l1, null);
    Label l2 = new Label();
    Label l3 = new Label();
    mv.visitTryCatchBlock(l2, l3, l1, null);
    Label l4 = new Label();
    mv.visitLabel(l4);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 2);
    Label l5 = new Label();
    mv.visitLabel(l5);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "count",
                      "Ljava/util/concurrent/atomic/AtomicInteger;");
    mv.visitVarInsn(ASTORE, 3);
    Label l6 = new Label();
    mv.visitLabel(l6);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "takeLock",
                      "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitVarInsn(ASTORE, 4);
    Label l7 = new Label();
    mv.visitLabel(l7);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "lockInterruptibly", "()V");
    mv.visitLabel(l0);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "head",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "last",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    Label l8 = new Label();
    mv.visitJumpInsn(IF_ACMPNE, l8);
    Label l9 = new Label();
    mv.visitLabel(l9);
    mv.visitTypeInsn(NEW, "com/tc/exception/TCRuntimeException");
    mv.visitInsn(DUP);
    mv.visitLdcInsn(TC_TAKE_METHOD_NAME + ": Trying to do a take from an empty queue.");
    mv.visitMethodInsn(INVOKESPECIAL, "com/tc/exception/TCRuntimeException", "<init>", "(Ljava/lang/String;)V");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l8);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", TC_EXTRACT_METHOD_NAME,
                       TC_EXTRACT_METHOD_DESC);
    mv.visitVarInsn(ASTORE, 1);
    Label l10 = new Label();
    mv.visitLabel(l10);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndDecrement", "()I");
    mv.visitVarInsn(ISTORE, 2);
    mv.visitJumpInsn(GOTO, l2);
    mv.visitLabel(l1);
    mv.visitVarInsn(ASTORE, 6);
    Label l11 = new Label();
    mv.visitJumpInsn(JSR, l11);
    Label l12 = new Label();
    mv.visitLabel(l12);
    mv.visitVarInsn(ALOAD, 6);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l11);
    mv.visitVarInsn(ASTORE, 5);
    Label l13 = new Label();
    mv.visitLabel(l13);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l14 = new Label();
    mv.visitLabel(l14);
    mv.visitVarInsn(RET, 5);
    mv.visitLabel(l2);
    mv.visitJumpInsn(JSR, l11);
    mv.visitLabel(l3);
    mv.visitVarInsn(ILOAD, 2);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    Label l15 = new Label();
    mv.visitJumpInsn(IF_ICMPNE, l15);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "signalNotFull", "()V");
    mv.visitLabel(l15);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitInsn(ARETURN);
    Label l16 = new Label();
    mv.visitLabel(l16);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
  }
  
  private MethodVisitor recreateOfferTimeoutMethod(MethodVisitor mv) {
    mv.visitCode();
    Label l0 = new Label();
    Label l1 = new Label();
    mv.visitTryCatchBlock(l0, l1, l1, "java/lang/InterruptedException");
    Label l2 = new Label();
    Label l3 = new Label();
    Label l4 = new Label();
    mv.visitTryCatchBlock(l2, l3, l4, null);
    mv.visitTryCatchBlock(l0, l4, l4, null);
    Label l5 = new Label();
    mv.visitLabel(l5);
    mv.visitLineNumber(325, l5);
    mv.visitVarInsn(ALOAD, 1);
    Label l6 = new Label();
    mv.visitJumpInsn(IFNONNULL, l6);
    mv.visitTypeInsn(NEW, "java/lang/NullPointerException");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL, "java/lang/NullPointerException", "<init>", "()V");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l6);
    mv.visitLineNumber(326, l6);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitVarInsn(LLOAD, 2);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/TimeUnit", "toNanos", "(J)J");
    mv.visitVarInsn(LSTORE, 5);
    Label l7 = new Label();
    mv.visitLabel(l7);
    mv.visitLineNumber(327, l7);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 7);
    Label l8 = new Label();
    mv.visitLabel(l8);
    mv.visitLineNumber(328, l8);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 8);
    Label l9 = new Label();
    mv.visitLabel(l9);
    mv.visitLineNumber(329, l9);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "putLock", "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitVarInsn(ASTORE, 9);
    Label l10 = new Label();
    mv.visitLabel(l10);
    mv.visitLineNumber(330, l10);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "count", "Ljava/util/concurrent/atomic/AtomicInteger;");
    mv.visitVarInsn(ASTORE, 10);
    Label l11 = new Label();
    mv.visitLabel(l11);
    mv.visitLineNumber(331, l11);
    mv.visitVarInsn(ALOAD, 9);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "lockInterruptibly", "()V");
    mv.visitLabel(l2);
    mv.visitLineNumber(334, l2);
    mv.visitVarInsn(ALOAD, 10);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    Label l12 = new Label();
    mv.visitJumpInsn(IF_ICMPGE, l12);
    Label l13 = new Label();
    mv.visitLabel(l13);
    mv.visitLineNumber(335, l13);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "insert", "(Ljava/lang/Object;)V");
    Label l14 = new Label();
    mv.visitLabel(l14);
    mv.visitLineNumber(336, l14);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "isManaged", "(Ljava/lang/Object;)Z");
    Label l15 = new Label();
    mv.visitJumpInsn(IFEQ, l15);
    Label l16 = new Label();
    mv.visitLabel(l16);
    mv.visitLineNumber(337, l16);
    mv.visitVarInsn(ALOAD, 10);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ISTORE, 7);
    Label l17 = new Label();
    mv.visitLabel(l17);
    mv.visitLineNumber(338, l17);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 9);
    mv.visitLdcInsn("put(Ljava/lang/Object;)V");
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "logicalInvokeWithTransaction", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V");
    Label l18 = new Label();
    mv.visitLabel(l18);
    mv.visitLineNumber(339, l18);
    mv.visitVarInsn(ALOAD, 10);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 8);
    Label l19 = new Label();
    mv.visitJumpInsn(GOTO, l19);
    mv.visitLabel(l15);
    mv.visitLineNumber(341, l15);
    mv.visitVarInsn(ALOAD, 10);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 7);
    mv.visitLabel(l19);
    mv.visitLineNumber(343, l19);
    mv.visitVarInsn(ILOAD, 7);
    mv.visitInsn(ICONST_1);
    mv.visitInsn(IADD);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    Label l20 = new Label();
    mv.visitJumpInsn(IF_ICMPGE, l20);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signal", "()V");
    Label l21 = new Label();
    mv.visitLabel(l21);
    mv.visitLineNumber(344, l21);
    mv.visitJumpInsn(GOTO, l20);
    mv.visitLabel(l12);
    mv.visitLineNumber(346, l12);
    mv.visitVarInsn(LLOAD, 5);
    mv.visitInsn(LCONST_0);
    mv.visitInsn(LCMP);
    mv.visitJumpInsn(IFGT, l0);
    mv.visitLabel(l3);
    mv.visitLineNumber(355, l3);
    mv.visitVarInsn(ALOAD, 9);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l22 = new Label();
    mv.visitLabel(l22);
    mv.visitLineNumber(346, l22);
    mv.visitInsn(ICONST_0);
    mv.visitInsn(IRETURN);
    mv.visitLabel(l0);
    mv.visitLineNumber(348, l0);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitVarInsn(LLOAD, 5);
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "awaitNanos", "(J)J");
    mv.visitVarInsn(LSTORE, 5);
    mv.visitJumpInsn(GOTO, l2);
    mv.visitLabel(l1);
    mv.visitLineNumber(349, l1);
    mv.visitVarInsn(ASTORE, 11);
    Label l23 = new Label();
    mv.visitLabel(l23);
    mv.visitLineNumber(350, l23);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signal", "()V");
    Label l24 = new Label();
    mv.visitLabel(l24);
    mv.visitLineNumber(351, l24);
    mv.visitVarInsn(ALOAD, 11);
    mv.visitInsn(ATHROW);
    Label l25 = new Label();
    mv.visitLabel(l25);
    mv.visitLineNumber(333, l25);
    mv.visitJumpInsn(GOTO, l2);
    mv.visitJumpInsn(GOTO, l20);
    mv.visitLabel(l4);
    mv.visitLineNumber(354, l4);
    mv.visitVarInsn(ASTORE, 12);
    Label l26 = new Label();
    mv.visitLabel(l26);
    mv.visitLineNumber(355, l26);
    mv.visitVarInsn(ALOAD, 9);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l27 = new Label();
    mv.visitLabel(l27);
    mv.visitLineNumber(356, l27);
    mv.visitVarInsn(ALOAD, 12);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l20);
    mv.visitLineNumber(355, l20);
    mv.visitVarInsn(ALOAD, 9);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l28 = new Label();
    mv.visitLabel(l28);
    mv.visitLineNumber(357, l28);
    mv.visitVarInsn(ILOAD, 7);
    Label l29 = new Label();
    mv.visitJumpInsn(IFEQ, l29);
    mv.visitVarInsn(ILOAD, 8);
    Label l30 = new Label();
    mv.visitJumpInsn(IFNE, l30);
    mv.visitLabel(l29);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "signalNotEmpty", "()V");
    mv.visitLabel(l30);
    mv.visitLineNumber(358, l30);
    mv.visitInsn(ICONST_1);
    mv.visitInsn(IRETURN);
    Label l31 = new Label();
    mv.visitLabel(l31);
    mv.visitLocalVariable("this", "Ljava/util/concurrent/LinkedBlockingQueue;", "Ljava/util/concurrent/LinkedBlockingQueue<TE;>;", l5, l31, 0);
    mv.visitLocalVariable("o", "Ljava/lang/Object;", "TE;", l5, l31, 1);
    mv.visitLocalVariable("timeout", "J", null, l5, l31, 2);
    mv.visitLocalVariable("unit", "Ljava/util/concurrent/TimeUnit;", null, l5, l31, 4);
    mv.visitLocalVariable("nanos", "J", null, l7, l31, 5);
    mv.visitLocalVariable("c", "I", null, l8, l31, 7);
    mv.visitLocalVariable("d", "I", null, l9, l31, 8);
    mv.visitLocalVariable("putLock", "Ljava/util/concurrent/locks/ReentrantLock;", null, l10, l31, 9);
    mv.visitLocalVariable("count", "Ljava/util/concurrent/atomic/AtomicInteger;", null, l11, l31, 10);
    mv.visitLocalVariable("ie", "Ljava/lang/InterruptedException;", null, l23, l25, 11);
    mv.visitMaxs(7, 13);
    mv.visitEnd();
    return null;
  }

  private MethodVisitor recreatePutMethod(MethodVisitor mv) {
    mv.visitCode();
    Label l0 = new Label();
    Label l1 = new Label();
    mv.visitTryCatchBlock(l0, l1, l1, "java/lang/InterruptedException");
    Label l2 = new Label();
    mv.visitTryCatchBlock(l0, l2, l2, null);
    Label l3 = new Label();
    mv.visitLabel(l3);
    mv.visitLineNumber(280, l3);
    mv.visitVarInsn(ALOAD, 1);
    Label l4 = new Label();
    mv.visitJumpInsn(IFNONNULL, l4);
    mv.visitTypeInsn(NEW, "java/lang/NullPointerException");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL, "java/lang/NullPointerException", "<init>", "()V");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l4);
    mv.visitLineNumber(283, l4);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 2);
    Label l5 = new Label();
    mv.visitLabel(l5);
    mv.visitLineNumber(284, l5);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "putLock", "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitVarInsn(ASTORE, 3);
    Label l6 = new Label();
    mv.visitLabel(l6);
    mv.visitLineNumber(285, l6);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "count", "Ljava/util/concurrent/atomic/AtomicInteger;");
    mv.visitVarInsn(ASTORE, 4);
    Label l7 = new Label();
    mv.visitLabel(l7);
    mv.visitLineNumber(286, l7);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "lockInterruptibly", "()V");
    Label l8 = new Label();
    mv.visitLabel(l8);
    mv.visitLineNumber(287, l8);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 5);
    mv.visitLabel(l0);
    mv.visitLineNumber(295, l0);
    Label l9 = new Label();
    mv.visitJumpInsn(GOTO, l9);
    Label l10 = new Label();
    mv.visitLabel(l10);
    mv.visitLineNumber(296, l10);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "await", "()V");
    mv.visitLabel(l9);
    mv.visitLineNumber(295, l9);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    mv.visitJumpInsn(IF_ICMPGE, l10);
    Label l11 = new Label();
    mv.visitJumpInsn(GOTO, l11);
    mv.visitLabel(l1);
    mv.visitLineNumber(298, l1);
    mv.visitVarInsn(ASTORE, 6);
    Label l12 = new Label();
    mv.visitLabel(l12);
    mv.visitLineNumber(299, l12);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signal", "()V");
    Label l13 = new Label();
    mv.visitLabel(l13);
    mv.visitLineNumber(300, l13);
    mv.visitVarInsn(ALOAD, 6);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l11);
    mv.visitLineNumber(302, l11);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "insert", "(Ljava/lang/Object;)V");
    Label l14 = new Label();
    mv.visitLabel(l14);
    mv.visitLineNumber(303, l14);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "isManaged", "(Ljava/lang/Object;)Z");
    Label l15 = new Label();
    mv.visitJumpInsn(IFEQ, l15);
    Label l16 = new Label();
    mv.visitLabel(l16);
    mv.visitLineNumber(304, l16);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ISTORE, 2);
    Label l17 = new Label();
    mv.visitLabel(l17);
    mv.visitLineNumber(305, l17);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitLdcInsn("put(Ljava/lang/Object;)V");
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "logicalInvokeWithTransaction", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V");
    Label l18 = new Label();
    mv.visitLabel(l18);
    mv.visitLineNumber(306, l18);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 5);
    Label l19 = new Label();
    mv.visitJumpInsn(GOTO, l19);
    mv.visitLabel(l15);
    mv.visitLineNumber(308, l15);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 2);
    mv.visitLabel(l19);
    mv.visitLineNumber(310, l19);
    mv.visitVarInsn(ILOAD, 2);
    mv.visitInsn(ICONST_1);
    mv.visitInsn(IADD);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    Label l20 = new Label();
    mv.visitJumpInsn(IF_ICMPGE, l20);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signal", "()V");
    mv.visitJumpInsn(GOTO, l20);
    mv.visitLabel(l2);
    mv.visitLineNumber(311, l2);
    mv.visitVarInsn(ASTORE, 7);
    Label l21 = new Label();
    mv.visitLabel(l21);
    mv.visitLineNumber(312, l21);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l22 = new Label();
    mv.visitLabel(l22);
    mv.visitLineNumber(313, l22);
    mv.visitVarInsn(ALOAD, 7);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l20);
    mv.visitLineNumber(312, l20);
    mv.visitVarInsn(ALOAD, 3);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l23 = new Label();
    mv.visitLabel(l23);
    mv.visitLineNumber(314, l23);
    mv.visitVarInsn(ILOAD, 2);
    Label l24 = new Label();
    mv.visitJumpInsn(IFEQ, l24);
    mv.visitVarInsn(ILOAD, 5);
    Label l25 = new Label();
    mv.visitJumpInsn(IFNE, l25);
    mv.visitLabel(l24);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "signalNotEmpty", "()V");
    mv.visitLabel(l25);
    mv.visitLineNumber(320, l25);
    mv.visitInsn(RETURN);
    Label l26 = new Label();
    mv.visitLabel(l26);
    mv.visitLocalVariable("this", "Ljava/util/concurrent/LinkedBlockingQueue;", "Ljava/util/concurrent/LinkedBlockingQueue<TE;>;", l3, l26, 0);
    mv.visitLocalVariable("o", "Ljava/lang/Object;", "TE;", l3, l26, 1);
    mv.visitLocalVariable("c", "I", null, l5, l26, 2);
    mv.visitLocalVariable("putLock", "Ljava/util/concurrent/locks/ReentrantLock;", null, l6, l26, 3);
    mv.visitLocalVariable("count", "Ljava/util/concurrent/atomic/AtomicInteger;", null, l7, l26, 4);
    mv.visitLocalVariable("d", "I", null, l0, l26, 5);
    mv.visitLocalVariable("ie", "Ljava/lang/InterruptedException;", null, l12, l11, 6);
    mv.visitMaxs(7, 8);
    mv.visitEnd();
    return null;
  }

  private MethodVisitor recreateOfferMethod(MethodVisitor mv) {
    mv.visitCode();
    Label l0 = new Label();
    Label l1 = new Label();
    mv.visitTryCatchBlock(l0, l1, l1, null);
    Label l2 = new Label();
    mv.visitLabel(l2);
    mv.visitLineNumber(370, l2);
    mv.visitVarInsn(ALOAD, 1);
    Label l3 = new Label();
    mv.visitJumpInsn(IFNONNULL, l3);
    mv.visitTypeInsn(NEW, "java/lang/NullPointerException");
    mv.visitInsn(DUP);
    mv.visitMethodInsn(INVOKESPECIAL, "java/lang/NullPointerException", "<init>", "()V");
    mv.visitInsn(ATHROW);
    mv.visitLabel(l3);
    mv.visitLineNumber(371, l3);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "count", "Ljava/util/concurrent/atomic/AtomicInteger;");
    mv.visitVarInsn(ASTORE, 2);
    Label l4 = new Label();
    mv.visitLabel(l4);
    mv.visitLineNumber(372, l4);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    Label l5 = new Label();
    mv.visitJumpInsn(IF_ICMPLT, l5);
    mv.visitInsn(ICONST_0);
    mv.visitInsn(IRETURN);
    mv.visitLabel(l5);
    mv.visitLineNumber(373, l5);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 3);
    Label l6 = new Label();
    mv.visitLabel(l6);
    mv.visitLineNumber(374, l6);
    mv.visitInsn(ICONST_M1);
    mv.visitVarInsn(ISTORE, 4);
    Label l7 = new Label();
    mv.visitLabel(l7);
    mv.visitLineNumber(375, l7);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "putLock", "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitVarInsn(ASTORE, 5);
    Label l8 = new Label();
    mv.visitLabel(l8);
    mv.visitLineNumber(376, l8);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "lock", "()V");
    mv.visitLabel(l0);
    mv.visitLineNumber(378, l0);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    Label l9 = new Label();
    mv.visitJumpInsn(IF_ICMPGE, l9);
    Label l10 = new Label();
    mv.visitLabel(l10);
    mv.visitLineNumber(379, l10);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "insert", "(Ljava/lang/Object;)V");
    Label l11 = new Label();
    mv.visitLabel(l11);
    mv.visitLineNumber(380, l11);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "isManaged", "(Ljava/lang/Object;)Z");
    Label l12 = new Label();
    mv.visitJumpInsn(IFEQ, l12);
    Label l13 = new Label();
    mv.visitLabel(l13);
    mv.visitLineNumber(381, l13);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "get", "()I");
    mv.visitVarInsn(ISTORE, 3);
    Label l14 = new Label();
    mv.visitLabel(l14);
    mv.visitLineNumber(382, l14);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitLdcInsn("put(Ljava/lang/Object;)V");
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "logicalInvokeWithTransaction", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V");
    Label l15 = new Label();
    mv.visitLabel(l15);
    mv.visitLineNumber(383, l15);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 4);
    Label l16 = new Label();
    mv.visitJumpInsn(GOTO, l16);
    mv.visitLabel(l12);
    mv.visitLineNumber(385, l12);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndIncrement", "()I");
    mv.visitVarInsn(ISTORE, 3);
    mv.visitLabel(l16);
    mv.visitLineNumber(387, l16);
    mv.visitVarInsn(ILOAD, 3);
    mv.visitInsn(ICONST_1);
    mv.visitInsn(IADD);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    mv.visitJumpInsn(IF_ICMPGE, l9);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull", "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signal", "()V");
    mv.visitJumpInsn(GOTO, l9);
    mv.visitLabel(l1);
    mv.visitLineNumber(389, l1);
    mv.visitVarInsn(ASTORE, 6);
    Label l17 = new Label();
    mv.visitLabel(l17);
    mv.visitLineNumber(390, l17);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l18 = new Label();
    mv.visitLabel(l18);
    mv.visitLineNumber(391, l18);
    mv.visitVarInsn(ALOAD, 6);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l9);
    mv.visitLineNumber(390, l9);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "unlock", "()V");
    Label l19 = new Label();
    mv.visitLabel(l19);
    mv.visitLineNumber(392, l19);
    mv.visitVarInsn(ILOAD, 3);
    Label l20 = new Label();
    mv.visitJumpInsn(IFEQ, l20);
    mv.visitVarInsn(ILOAD, 4);
    Label l21 = new Label();
    mv.visitJumpInsn(IFNE, l21);
    mv.visitLabel(l20);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "signalNotEmpty", "()V");
    mv.visitLabel(l21);
    mv.visitLineNumber(393, l21);
    mv.visitVarInsn(ILOAD, 3);
    Label l22 = new Label();
    mv.visitJumpInsn(IFLT, l22);
    mv.visitInsn(ICONST_1);
    mv.visitInsn(IRETURN);
    mv.visitLabel(l22);
    mv.visitInsn(ICONST_0);
    mv.visitInsn(IRETURN);
    Label l23 = new Label();
    mv.visitLabel(l23);
    mv.visitLocalVariable("this", "Ljava/util/concurrent/LinkedBlockingQueue;", "Ljava/util/concurrent/LinkedBlockingQueue<TE;>;", l2, l23, 0);
    mv.visitLocalVariable("o", "Ljava/lang/Object;", "TE;", l2, l23, 1);
    mv.visitLocalVariable("count", "Ljava/util/concurrent/atomic/AtomicInteger;", null, l4, l23, 2);
    mv.visitLocalVariable("c", "I", null, l6, l23, 3);
    mv.visitLocalVariable("d", "I", null, l7, l23, 4);
    mv.visitLocalVariable("putLock", "Ljava/util/concurrent/locks/ReentrantLock;", null, l8, l23, 5);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
    return null;
  }

  // Rewriting the remove(Object) method of LinkedBlockingQueue with instrumented code.
  private MethodVisitor recreateRemoveMethod(MethodVisitor mv) {
    mv.visitCode();
    Label l0 = new Label();
    Label l1 = new Label();
    mv.visitTryCatchBlock(l0, l1, l1, null);
    Label l2 = new Label();
    mv.visitLabel(l2);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ISTORE, 2);
    Label l3 = new Label();
    mv.visitLabel(l3);
    mv.visitVarInsn(ALOAD, 1);
    Label l4 = new Label();
    mv.visitJumpInsn(IFNONNULL, l4);
    mv.visitInsn(ICONST_0);
    mv.visitInsn(IRETURN);
    mv.visitLabel(l4);
    mv.visitInsn(ICONST_0);
    mv.visitVarInsn(ISTORE, 3);
    Label l5 = new Label();
    mv.visitLabel(l5);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "fullyLock", "()V");
    mv.visitLabel(l0);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "head",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitVarInsn(ASTORE, 4);
    Label l6 = new Label();
    mv.visitLabel(l6);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "head",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "next",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitVarInsn(ASTORE, 5);
    Label l7 = new Label();
    mv.visitLabel(l7);
    Label l8 = new Label();
    mv.visitJumpInsn(GOTO, l8);
    Label l9 = new Label();
    mv.visitLabel(l9);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "item", "Ljava/lang/Object;");
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Object", "equals", "(Ljava/lang/Object;)Z");
    Label l10 = new Label();
    mv.visitJumpInsn(IFEQ, l10);
    Label l11 = new Label();
    mv.visitLabel(l11);
    mv.visitInsn(ICONST_1);
    mv.visitVarInsn(ISTORE, 3);
    Label l12 = new Label();
    mv.visitLabel(l12);
    Label l13 = new Label();
    mv.visitJumpInsn(GOTO, l13);
    mv.visitLabel(l10);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitVarInsn(ASTORE, 4);
    Label l14 = new Label();
    mv.visitLabel(l14);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "next",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitVarInsn(ASTORE, 5);
    Label l15 = new Label();
    mv.visitLabel(l15);
    mv.visitIincInsn(2, 1);
    mv.visitLabel(l8);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitJumpInsn(IFNONNULL, l9);
    mv.visitLabel(l13);
    mv.visitVarInsn(ILOAD, 3);
    Label l16 = new Label();
    mv.visitJumpInsn(IFEQ, l16);
    Label l17 = new Label();
    mv.visitLabel(l17);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitInsn(ACONST_NULL);
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "item", "Ljava/lang/Object;");
    Label l18 = new Label();
    mv.visitLabel(l18);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitVarInsn(ALOAD, 5);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "next",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "next",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    Label l19 = new Label();
    mv.visitLabel(l19);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "isManaged", "(Ljava/lang/Object;)Z");
    Label l20 = new Label();
    mv.visitJumpInsn(IFEQ, l20);
    Label l21 = new Label();
    mv.visitLabel(l21);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitLdcInsn(SerializationUtil.REMOVE_AT_SIGNATURE);
    mv.visitInsn(ICONST_1);
    mv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
    mv.visitInsn(DUP);
    mv.visitInsn(ICONST_0);
    mv.visitTypeInsn(NEW, "java/lang/Integer");
    mv.visitInsn(DUP);
    mv.visitVarInsn(ILOAD, 2);
    mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Integer", "<init>", "(I)V");
    mv.visitInsn(AASTORE);
    mv.visitMethodInsn(INVOKESTATIC, "com/tc/object/bytecode/ManagerUtil", "logicalInvoke",
                       "(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V");
    mv.visitLabel(l20);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "last",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitVarInsn(ALOAD, 5);
    Label l22 = new Label();
    mv.visitJumpInsn(IF_ACMPNE, l22);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 4);
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue", "last",
                      "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitLabel(l22);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "count",
                      "Ljava/util/concurrent/atomic/AtomicInteger;");
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/atomic/AtomicInteger", "getAndDecrement", "()I");
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "capacity", "I");
    mv.visitJumpInsn(IF_ICMPNE, l16);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull",
                      "Ljava/util/concurrent/locks/Condition;");
    mv.visitMethodInsn(INVOKEINTERFACE, "java/util/concurrent/locks/Condition", "signalAll", "()V");
    mv.visitJumpInsn(GOTO, l16);
    mv.visitLabel(l1);
    mv.visitVarInsn(ASTORE, 6);
    Label l23 = new Label();
    mv.visitLabel(l23);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "fullyUnlock", "()V");
    Label l24 = new Label();
    mv.visitLabel(l24);
    mv.visitVarInsn(ALOAD, 6);
    mv.visitInsn(ATHROW);
    mv.visitLabel(l16);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitMethodInsn(INVOKESPECIAL, "java/util/concurrent/LinkedBlockingQueue", "fullyUnlock", "()V");
    Label l25 = new Label();
    mv.visitLabel(l25);
    mv.visitVarInsn(ILOAD, 3);
    mv.visitInsn(IRETURN);
    Label l26 = new Label();
    mv.visitLabel(l26);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
    return null;
  }

  private void addInitMethodCode() {
    MethodVisitor mv = super.visitMethod(ACC_PRIVATE + ACC_SYNTHETIC, "init", "()V", null, null);
    mv.visitCode();
    ByteCodeUtil.pushThis(mv);
    ByteCodeUtil.pushThis(mv);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "takeLock",
                      "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "newCondition",
                       "()Ljava/util/concurrent/locks/Condition;");
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue", "notEmpty",
                      "Ljava/util/concurrent/locks/Condition;");
    ByteCodeUtil.pushThis(mv);
    ByteCodeUtil.pushThis(mv);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "putLock",
                      "Ljava/util/concurrent/locks/ReentrantLock;");
    mv.visitMethodInsn(INVOKEVIRTUAL, "java/util/concurrent/locks/ReentrantLock", "newCondition",
                       "()Ljava/util/concurrent/locks/Condition;");
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue", "notFull",
                      "Ljava/util/concurrent/locks/Condition;");
    mv.visitInsn(RETURN);
    mv.visitMaxs(0, 0);
    mv.visitEnd();
  }
  
  private void addTCExtractMethod() {
    MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, TC_EXTRACT_METHOD_NAME, TC_EXTRACT_METHOD_DESC, "()TE;", null);
    mv.visitCode();
    Label l0 = new Label();
    mv.visitLabel(l0);
    mv.visitLineNumber(144, l0);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue", "head", "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "next", "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    mv.visitVarInsn(ASTORE, 1);
    Label l1 = new Label();
    mv.visitLabel(l1);
    mv.visitLineNumber(145, l1);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue", "head", "Ljava/util/concurrent/LinkedBlockingQueue$Node;");
    Label l2 = new Label();
    mv.visitLabel(l2);
    mv.visitLineNumber(146, l2);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitFieldInsn(GETFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "item", "Ljava/lang/Object;");
    mv.visitVarInsn(ASTORE, 2);
    Label l3 = new Label();
    mv.visitLabel(l3);
    mv.visitLineNumber(147, l3);
    mv.visitVarInsn(ALOAD, 1);
    mv.visitInsn(ACONST_NULL);
    mv.visitFieldInsn(PUTFIELD, "java/util/concurrent/LinkedBlockingQueue$Node", "item", "Ljava/lang/Object;");
    Label l4 = new Label();
    mv.visitLabel(l4);
    mv.visitLineNumber(148, l4);
    mv.visitVarInsn(ALOAD, 2);
    mv.visitInsn(ARETURN);
    Label l5 = new Label();
    mv.visitLabel(l5);
    mv.visitLocalVariable("this", "Ljava/util/concurrent/LinkedBlockingQueue;", "Ljava/util/concurrent/LinkedBlockingQueue<TE;>;", l0, l5, 0);
    mv.visitLocalVariable("first", "Ljava/util/concurrent/LinkedBlockingQueue$Node;", "Ljava/util/concurrent/LinkedBlockingQueue$Node<TE;>;", l1, l5, 1);
    mv.visitLocalVariable("x", "Ljava/lang/Object;", "TE;", l3, l5, 2);
    mv.visitMaxs(2, 3);
    mv.visitEnd();
  }

  static class NodeMethodAdapter extends MethodAdapter implements Opcodes {
    public NodeMethodAdapter(MethodVisitor mv) {
      super(mv);
    }

    public void visitFieldInsn(int opcode, String owner, String name, String desc) {
      if (GETFIELD == opcode && "java/util/concurrent/LinkedBlockingQueue$Node".equals(owner) && "item".equals(name)
          && "Ljava/lang/Object;".equals(desc)) {
        mv.visitMethodInsn(INVOKEVIRTUAL, owner, GET_ITEM_METHOD_NAME, GET_ITEM_METHOD_DESC);
      } else {
        super.visitFieldInsn(opcode, owner, name, desc);
      }
    }
  }
}
