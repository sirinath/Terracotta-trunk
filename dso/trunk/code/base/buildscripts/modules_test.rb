#
# All content copyright (c) 2003-2006 Terracotta, Inc.,
# except as may otherwise be noted in a separate copyright notice.
# All rights reserved
#

# Adds methods to BuildSubtree that allow you to run JUnit tests on it. This is probably
# the most complex single file in the entire buildsystem.

# The prefix that we use for dynamically-generated properties -- that is, those that are
# created by the buildsystem out of its own internal information, and not simply information
# manually specified by the user and merely ferried across.
DYNAMICALLY_GENERATED_PROPERTIES_PREFIX = 'tc.tests.info.'

# The prefix that we use for statically-generated properties -- that is, those that are
# specified by the user (or monkey, or configuration file) and simply ferried across to
# the tests.
STATIC_PROPERTIES_PREFIX = 'tc.tests.configuration.'

module PropertyUtils
  def property_string(key, value)
    "#{key.escape}=#{value.escape}"
  end
end

class BuildSubtree
    include PropertyUtils

    # Creates a SubtreeTestRun object for this subtree and returns it. Most of the arguments
    # are self-explanatory (they're the obvious instances of the classes with the same names);
    # test_patterns is an array of Ant-style patterns (e.g., "**/*Test") that indicates
    # which tests should be run. aggregation_directory, if non-nil, is a directory into
    # which we should copy the XML result files for all tests. (This is used for
    # CruiseControl, since we want to be able to point it at a single directory of XML
    # log files from test runs, not one per subtree.)
    def test_run(testrun_results, test_patterns, aggregation_directory=nil)
        SubtreeTestRun.new(self, buildconfig_properties, testrun_results, test_patterns, aggregation_directory)
    end

    def container_home
      ENV['TC_CONTAINER_HOME']
    end

    def create_dynamic_property(key, value)
      DYNAMICALLY_GENERATED_PROPERTIES_PREFIX + property_string(key, value)
    end

    # Creates a property file (in the style of java.util.Properties.load()) that contains all
    # the information necessary for the TestConfigObject to do its job and return the
    # appropriate information.
    def create_build_configuration_file(static_resources, testrun_results, build_results, build_environment, config_source, boot_jar, ant, jvm, jvmargs, timeout)
        File.open(testrun_results.build_configuration_file(self).to_s, "w") do |file|
            file << "# Dynamic properties: pieces of information generated by the buildsystem and passed to the Java code\n"
            # The root of the classname-based directory hierarchy used for temporary files created by tests
            write_dynamic_property(file, "temp-root", testrun_results.temp_dir(self))
            # The root of the classname-based directory hierarchy used for data files that tests need
            write_dynamic_property(file, "data-root", build_test_data_directory(testrun_results, ant))
            # The CLASSPATH that should be used for the LinkedChildProcess; this needs to be quite minimal (which
            # is why that class is pretty much in its own module), as it's in the CLASSPATH used to run application
            # servers -- and they typically don't like it if you put random stuff in their CLASSPATH that isn't
            # their own classes.
            write_dynamic_property(file, "linked-child-process-classpath", build_module.module_set['linked-child-process'].subtree('src').classpath(build_results, :full, :runtime))

            if container_home
                write_dynamic_property(file, "appserver.home", container_home)
            end

            # Builds up the set of classes required for DSO to support sessions
            sessionSet = PathSet.new
            %w(session tomcat tomcat50 tomcat55 weblogic).each do |mod|
              sessionSet << build_module.module_set["dso-l1-#{mod}"].subtree('src').own_classes_only_classpath(build_results)
            end

            # Writes out the location of the boot JAR for this tree, if one was created.
            write_dynamic_property(file, "bootjars.normal", boot_jar.path) unless boot_jar.nil?
            # Writes out the location of the session CLASSPATH that DSO needs
            write_dynamic_property(file, "session.classpath", sessionSet)
            # Writes out the location of the path that tests should use to search for executables; currently,
            # this is just precisely the native library path.
            write_dynamic_property(file, "executable-search-path", native_library_path(build_results, build_environment, :full))
            # The timeout the tests are going to use. This does *not* actually set the timeout;
            # that's set in the Ant <junit> task. Rather, this is so that the test can fire off
            # a thread dump before it's timed out.
            write_dynamic_property(file, "junit-test-timeout-inseconds", (timeout/1000))

            # The JVM version (e.g., "1.4.2_07"), type (e.g., "hotspot"), and mode (e.g., "client" or "server")
            # that should be used. This is used for a couple tests we have checked in, which make sure they're
            # running with the VM we think they should be running with. (Without them, we are just relying on
            # the buildsystem to spawn the right VM and get it right with no checks; this is a recipe for getting
            # it quite wrong. In fact, these tests already caught a bug; we used to run either with '-server' or
            # without '-server', but never with '-client'. 1.5 decides to pick a VM based on the machine's RAM
            # capacity, number of CPUs, and so on, and so it actually picked server even when we didn't request it.
            # Long story short, you should keep those tests around, and use this code, because it actually
            # really does make a difference.)
            write_dynamic_property(file, "jvm.version", jvm.actual_version)
            write_dynamic_property(file, "jvm.type", jvm.actual_type)
            write_dynamic_property(file, "jvm.mode", (jvmargs.any? { |x| x =~ /-server/i }) ? "server" : "client")

            # Write out the properties that control how the L2 is started.  Since the L2 requires
            # a 1.5 or higher JVM, it must be started in an external JVM if the current JVM is 1.4.
            jvm_15 = Registry[:jvm_set].find_jvm(:min_version => '1.5.0')
            fail("Can't find JVM 15 or greater to run L2") unless jvm_15
            write_dynamic_property(file, "l2.startup.jvm", jvm_15.home.to_s)

            if jvm.version < '1.5.0'
              write_dynamic_property(file, "l2.startup.mode", "external")
            else
              write_dynamic_property(file, "l2.startup.mode", "internal")
            end

            # Write out which variant values are available for each variant name, and write out which libraries
            # should be included if the given variant is set to each of the possible values. Right now, this is
            # *all* that variants do -- they do not *ever* actually change the CLASSPATH of what we spawn, because
            # they're only needed for container tests right now (and container tests spawn their own VMs and thus
            # just read these properties directly).
            full_all_variants.each do |variant_name, variant_values|
              write_dynamic_property(file, "variants.available.#{variant_name}", variant_values.join(","))
              variant_values.each do |variant_value|
                write_dynamic_property(file, "libraries.variants.#{variant_name}.#{variant_value}",
                                       full_variant_libraries(variant_name, variant_value))
              end
            end

            # Looks for selected variants, and writes out information about which variant is selected.
            config_source.keys.sort.each do |key|
              if key =~ /^variant\.([^\.]+)$/i
                variant_name = $1
                variant_value = config_source[key]

                unless full_all_variants[variant_name].include?(variant_value)
                  raise "There is no variant '#{variant_value}' for '#{variant_name}'!"
                end
                write_dynamic_property(file, "variants.selected.#{variant_name}", variant_value)
              end
            end

            # Writes out the 'short path temporary directory', which is used by the container code to put
            # app servers into a directory that has a shorter pathname prefix. This is so that Windows,
            # which sucks all kinds of ass, doesn't screw us with its limitations on pathname length.
            if build_environment.has_pathname_length_limitations? && (! config_source['SHORT_PATH_TEMPDIR'].blank?)
                write_dynamic_property(file, "short-path-tempdir", config_source['SHORT_PATH_TEMPDIR'])
            end

            # Writes out all static properties -- these are ones that start with 'tc.tests.configuration.', and
            # are merely passed through from the configuration source (typically the command line and build-config.(local|global)
            # files) to the TestConfigObject).
            file << "\n"
            file << "# Static properties: those specified manually by the user or CruiseControl configuration, not the buildsystem\n"
            write_static_properties(file, config_source)
        end
    end

    protected
    # Copies all test data for this subtree to the given directory.
    def copy_subtree_test_data_to_directory(dest_directory, ant)
        out = 0

        if FileTest.exist?(test_data_source_directory.to_s)
            out += 1
            ant.copy(:todir => dest_directory.to_s) {
                ant.fileset(:dir => test_data_source_directory.to_s)
            }
        end

        out
    end

    # Copies all test data for this subtree, and for any subtrees in the same build module that
    # it's dependent upon, to the given directory.
    def copy_module_test_data_to_directory(dest_directory, ant)
        out = 0

        @internal_dependencies.each do |internal_dependency|
            out += build_module.subtree(internal_dependency).copy_subtree_test_data_to_directory(dest_directory, ant)
        end

        out += copy_subtree_test_data_to_directory(dest_directory, ant)
        out
    end

    private
    # Writes out a 'dynamic' property -- one starting with the DYNAMICALLY_GENERATED_PROPERTIES_PREFIX --
    # to the given file.
    def write_dynamic_property(file, key, value)
        file << "#{create_dynamic_property(key, value)}\n"
    end

    # Writes out all properties that start with the STATIC_PROPERTIES_PREFIX from the given
    # configuration source to the given file.
    def write_static_properties(file, config_source)
        config_source.keys.each do |key|
            if key.starts_with?(STATIC_PROPERTIES_PREFIX)
                file << property_string(key, config_source[key]) + "\n"
            end
        end
    end

    # Where is the build configuration file, that contains settings that affect how we
    # run tests on this subtree?
    def test_buildconfig_file
        FilePath.new(build_module.root, @name + ".buildconfig")
    end

    # The directory that data files for this subtree are found in.
    def test_data_source_directory
        FilePath.new(build_module.root, @name + ".data")
    end

    # Computes the build-configuration properties, which affect how we run tests on this
    # subtree. These are read from a properties-style file at <module>/<subtree>.buildconfig,
    # if it exists; otherwise, they're empty. Returns a hash.
    def buildconfig_properties
        if @buildconfig_properties.nil?
            @buildconfig_properties = { }
            filepath = test_buildconfig_file.to_s
            if File.file?(filepath)
                File.open(filepath) do |file|
                    lineno = 1
                    file.each do |line|
                        if line =~ /^\s*(\S[^=]+?)\s*=\s*(\S.*?)\s*$/
                            @buildconfig_properties[$1] = $2
                        elsif line =~ /^\s*#.*$/ || line =~ /^\s*$/
                            # Nothing here
                        else
                            raise "#{filepath}:%d: Line is an invalid format: #{line}" % [ lineno ]
                        end

                        lineno += 1
                    end
                end
            end
        end

        @buildconfig_properties
    end

    # Builds the test-data directory, which contains test data for this subtree and any
    # subtree this subtree is dependent upon. This is so that test code can ask for the data
    # directory and know it'll get its data, rather than having to make sure it's only when
    # it's running tests from the actual subtree it's in.
    def build_test_data_directory(testrun_results, ant)
        dir = testrun_results.tests_data_dir(self)

        directories_copied_from = copy_all_test_data_to_directory(dir, ant)
        if directories_copied_from > 0
            word = "director" + (directories_copied_from == 1 ? "y" : "ies")
            puts("Compiled test data from #{directories_copied_from} #{word} into '#{dir}' for tests on '#{module_subtree_name}'.")
        else
            puts "No data directories found for '#{module_subtree_name}', or its dependencies."
        end
        dir
    end

    # Copies all test data to the given directory, from this subtree and all the subtrees
    # it's dependent upon.
    def copy_all_test_data_to_directory(dest_directory, ant)
        out = 0

        build_module.dependent_modules.each do |dependent_module|
            out += dependent_module.subtree(@external_dependencies_like).copy_module_test_data_to_directory(dest_directory, ant)
        end

        out += copy_module_test_data_to_directory(dest_directory, ant)
        out
    end
end

# A SubtreeTestRun object is what actually runs tests on a tree. Basically, you ask a BuildSubtree
# to create one for you, and you can then use it to set up for tests, run tests, prepare to run
# them externally (i.e., in Eclipse), or have it print out how it would run tests. This therefore
# encapsulates all test set-up, run, and tear-down logic into a single place so that you can do
# whatever you want with it.
class SubtreeTestRun
    include PropertyUtils

    # The default timeout for tests, in seconds. Currently, this is 15 minutes.
    DEFAULT_TEST_TIMEOUT_SECONDS = 15 * 60

    # Creates a new instance. Most of the parameters should be obvious; they're just references
    # to the obvious instances of the similarly-named classes. buildconfig is the build-configuration
    # hash (see BuildSubtree#buildconfig_properties, above); test_patterns is an array of Ant-style
    # patterns indicating which tests should be run, and aggregation_directory is a directory to
    # copy the result XML files into when we're done running tests.
    def initialize(subtree, buildconfig, testrun_results, test_patterns, aggregation_directory)
        @subtree = subtree
        @build_module = @subtree.build_module
        @static_resources = Registry[:static_resources]
        @buildconfig = buildconfig
        @testrun_results = testrun_results
        @test_patterns = test_patterns
        @build_results = Registry[:build_results]
        @build_environment = Registry[:build_environment]
        @config_source = Registry[:config_source]
        @internal_config_source = Registry[:internal_config_source]
        @ant = Registry[:ant]
        @platform = Registry[:platform]
        @aggregation_directory = aggregation_directory
        @use_dso_boot_jar = buildconfig['include-dso-boot-jar'] =~ /^\s*true\s*$/i
        @needs_dso_boot_jar = @use_dso_boot_jar || (buildconfig['build-dso-boot-jar'] =~ /^\s*true\s*$/i)
        @timeout = (@config_source["test_timeout"] || buildconfig["timeout"] || DEFAULT_TEST_TIMEOUT_SECONDS.to_s).to_i * 1000

        @extra_jvmargs = @config_source.as_array('jvmargs') || []
        if buildconfig['jvmargs']
          jvmargs = buildconfig['jvmargs'].split(/\s*,\s*/)
          # Make sure the heap size settings in the buildconfig override the
          # global heap size settings.
          jvmargs.each do |jvmarg|
            if match = /-Xm([sx])/.match(jvmarg)
              @extra_jvmargs.delete_if { |arg| arg =~ /-Xm#{match[1]}/ }
            end
            @extra_jvmargs << jvmarg
          end
        end

        if test_props = buildconfig['test.tc.properties']
          props_file = FilePath.new(@build_results.classes_directory(@subtree), test_props).canonicalize
          @extra_jvmargs << "-Dcom.tc.properties=#{props_file.to_propertyfile_escaped_s}"
        end
    end

    # Returns true if this test run requires a container to run.
    def requires_container?
      @requires_container ||= @buildconfig['requires-container'] =~ /^\s*true\s*$/i
    end

    # Does all preparations necessary to run the given set of tests.
    def setUp

        @has_tests = @subtree.source_exists
        if @has_tests
            @found_tests = find_tests
            @has_tests = ! @found_tests.empty?
        end

        # Skip preparations if we're not actually running any tests on this tree; doing things
        # like building the DSO boot JAR takes time, and it's pointless if we're not actually
        # going to run any tests on this tree (which we might not do depending on how the
        # patterns are set...).
        if ! @has_tests
            @setUp = true
            return
        end

        # tests_jvm will raise an exception if there is a problem with the JVM configuration
        tests_jvm

        if tests_jvm.actual_type =~ /ibm/i
          @extra_jvmargs << "-Xdump:java:file=-"
        end

        add_debug_jvmargs

        puts "------------------------------------------------------------------------"
        puts "PREPARING to run tests (#{@test_patterns.join(", ")}) on subtree '#{@subtree.module_subtree_name}'..."
        puts ""

        # Build a DSO boot JAR, if necessary.
        boot_jar = nil
        if @needs_dso_boot_jar
            if @config_source['boot_jar_path']
              loud_message("Using user specified boot JAR at #{@config_source['boot_jar_path']}")
              boot_jar = UserBootJar.new(@config_source['boot_jar_path'])
            else
              module_set = @subtree.build_module.module_set
              boot_jar_config_file = @subtree.boot_jar_config_file(@static_resources)

              boot_jar_base_dir = @build_results.shared_boot_jar_directory
              if boot_jar_config_file == @static_resources.dso_boot_jar_config_file
                boot_jar_dir = FilePath.new(boot_jar_base_dir, 'standard')
              else
                basename = Regexp.new(BuildSubtree::BOOT_JAR_CONFIG_FILE_BASENAME)
                subdir = "#{@subtree.build_module.name}-#{boot_jar_config_file.filename.to_s.gsub(basename, '')}"
                boot_jar_dir = FilePath.new(boot_jar_base_dir, subdir)
              end

              boot_jar = BootJar.new(tests_jvm, boot_jar_dir, module_set, boot_jar_config_file.to_s)

              reuse_boot_jars = (@config_source[STATIC_PROPERTIES_PREFIX + 'reuse_boot_jars'] =~ /true/i) ? true : false
              boot_jar_up_to_date = boot_jar.exist? &&
                                    (File.mtime(boot_jar.path.to_s) > File.mtime(boot_jar_config_file.to_s))
              if reuse_boot_jars && boot_jar_up_to_date
                puts("Using existing boot JAR at #{boot_jar.path}")
              else
                puts("This subtree requires a DSO boot JAR to run tests. Building boot JAR using config file #{boot_jar_config_file}")
                begin
                  boot_jar_create_time =  time do boot_jar.ensure_created(:delete_existing => !reuse_boot_jars) end
                  puts("Boot JAR creation took #{boot_jar_create_time} seconds")
                rescue => e
                  error_msg = "Failed to create boot JAR for: #{@test_patterns.join(", ")} under module " +
                              @subtree.build_module.name + ".  Exception: #{e}"
                  STDERR.puts(error_msg)
                  raise(error_msg)
                end
              end 
              FileUtils.copy(boot_jar.path.to_s, @testrun_results.boot_jar_directory(@subtree).ensure_directory.to_s)
            end
        end

        # This is necessary to make Log4J behave correctly. Ah, Log4J is insane.
        if FileTest.exist?(@static_resources.log4j_properties_file.to_s)
            @ant.copy(:file => @static_resources.log4j_properties_file.to_s, :todir => @testrun_results.temp_dir(@subtree).to_s)
        end

        # download appserver and set appserver.home if needed
        download_appserver_if_needed()

        # Set the tc.tests.configuration.transparent-tests.mode property if necessary
        if mode = @config_source['test.mode']
          @internal_config_source['tc.tests.configuration.transparent-tests.mode'] = mode
        end

        # This creates the file that TestConfigObject reads.
        @subtree.create_build_configuration_file(@static_resources, @testrun_results, @build_results, @build_environment, @config_source, boot_jar, @ant, tests_jvm, all_jvmargs, @timeout)

        native_library_path = @subtree.native_library_path(@build_results, @build_environment, :full)

        @jvmargs = [ ]

        modules_url = @build_results.modules_home.to_url

        # 'tc.tests.info.property-files' is set so that TestConfigObject knows which file to go read.
        @sysproperties = {
            'tc.base-dir' => @static_resources.root_dir.to_s,
            'java.awt.headless' => true,
            'tc.tests.info.property-files' => @testrun_results.build_configuration_file(@subtree).to_s,
            'com.tc.l1.modules.repositories' => modules_url
        }

        @sysproperties['java.library.path'] = native_library_path.to_s unless native_library_path.to_s.blank?

        if @use_dso_boot_jar
            @jvmargs << "-Xbootclasspath/p:#{boot_jar.path}"
            @sysproperties.merge!({
                'tc.config' => @static_resources.dso_test_runtime_config_file,
                'tc.dso.globalmode' => false
                })
        end

        # We run the tests with CWD set to the temporary directory, just in case the
        # test decides to just new up files directly (without using the temporary-directory
        # stuff) and write them.
        @cwd = @testrun_results.temp_dir(@subtree)
        @classpath = @subtree.classpath(@build_results, :full, :runtime)

        # This is *quite* important. If something goes really wrong with a test, to the point where it
        # crashes, doesn't even get started, hangs hard-core, or otherwise can't write out its result
        # XML file, then, without this, we'll never know about it -- which is really, really bad.
        # Instead, we write out these "test didn't run" XML files ahead of time, and let the tests
        # overwrite them as they go; this way, it's positive, instead of negative, feedback -- we only
        # count the test as having passed if we *know* it passed, rather than only counting it as
        # having failed if we *know* it failed. Much better.
        puts "Writing out 'did-not-run' XML files for the #{@found_tests.size} " +
             "test(s) in #{@subtree.build_module.name}/#{@subtree.name}..."
        @found_tests.each do |found_test|
            class_name = @build_results.class_name_for_class_file(@subtree, found_test)
            unless FilePath.new(found_test).filename =~ /\$/
              create_did_not_run_file(class_name, @testrun_results.results_file(@subtree, class_name))
            end
        end

        puts "Done."

        @setUp = true
    end

    def download_appserver_if_needed
      appserver_home = @config_source['tc.tests.configuration.appserver.home']
      if requires_container?
        if appserver_home
          if File.exist?(appserver_home)
            puts "** Appserver home is specified #{appserver_home}"
            return
          else
            fail("Appserver home specified [#{appserver_home}] but path not found!")
          end
        end

        url = @config_source['tc.tests.configuration.appserver.repository']
        fail("Neither [tc.tests.configuration.appserver.home] OR [tc.tests.configuration.appserver.repository] was specified!") unless url

        appserver = @config_source['tc.tests.configuration.appserver.factory.name'] + "-" +
                    @config_source['tc.tests.configuration.appserver.major-version'] + "." +
                    @config_source['tc.tests.configuration.appserver.minor-version']

        cache_location = @build_environment.os_type(:nice) =~ /windows/i ? 'c:/temp/appservers' : "#{ENV['HOME']}/.tc/appservers"

        appserver_home = File.join(cache_location, appserver)
        if File.exist?(appserver_home)
          puts "** Found cached version of #{appserver} at #{cache_location}"
        else
          FilePath.new(cache_location).ensure_directory
          os_name = @build_environment.os_type(:nice).downcase
          os_name = "win32" if os_name =~ /windows/
          url = url + "/" + @config_source['tc.tests.configuration.appserver.factory.name'] + "/" + os_name + "/" + appserver + ".zip"
          appserver_zip_path = appserver_home + ".zip"
          @ant.get(:src => url, :dest => appserver_zip_path)
          # we don't use @ant.unzip because it doesn't preserve executable bit of .sh files
          @ant.exec(:executable => "unzip", :dir => cache_location) do
            @ant.arg(:value => appserver_zip_path)
          end
          @ant.delete(:file => appserver_zip_path)
        end
        @internal_config_source['tc.tests.configuration.appserver.home'] = appserver_home
      end
    end

    # The list of system properties that *must* be set directly on the spawned JVM, rather than
    # being able to be set by TestConfigObject calling System.setProperty() from its static
    # initializer block. These are system properties that the JVM itself reads, or that DSO
    # (which loads from the bootclasspath, long, long before TestConfigObject loads) uses.
    #
    # It's also just a bad idea in the case of running tests in Eclipse, the use of this variable
    # is commented out below; there is a comment there.
    NON_CLASSPATH_LOADABLE_SYSTEM_PROPERTIES = [ 'java.library.path', 'tc.config', 'tc.dso.globalmode', "#{STATIC_PROPERTIES_PREFIX}modules.url" ]

    # Prepares to have tests in this tree run externally (i.e., but Eclipse). This mostly just
    # sets up a properties file that contains a list of system properties for TestConfigObject
    # to set when it's initialized, plus writes out a 'stamp' file indicating which tree
    # we've prepared the tests for.
    #
    # (TestConfigObject loads its file using TestConfigObject.class.getResource(); as such,
    # it loads this file from its own class tree in the filesystem, and so we overwrite it
    # no matter what subtree we're preparing a test run for. Because different subtrees are
    # configured differently and thus will put different things into this file, we have to
    # keep track of what tree we're currently prepared for so that the Eclipse tool that
    # runs Terracotta tests from Eclipse knows whether or not to re-run 'check_prep'.
    #
    # Yes, people have bitched and moaned about this, but it's not remotely clear to me that
    # there's an easier way. If you mandated -- and could enforce -- that every single last
    # test class in the system inherited from TCTestCase, you could have TestConfigObject
    # fetch its resource based on that class, and therefore load the right file...I think.
    # There's still some discussion about whether or not getResource() only looks in the part
    # of the CLASSPATH where the class you called it on was loaded, or if it re-searches
    # the whole CLASSPATH from the top every time. If the latter, then you're *really* screwed.)
    def prepare_for_external_run
        raise "You must call setUp before running this method." unless @setUp

        if ! @has_tests
            return
        end

        test_config_system_properties_file = @build_results.test_config_system_properties_file(@subtree.build_module.module_set)

        # Write out the system properties that we need to set.
        File.open(test_config_system_properties_file.to_s, "w") do |file|
            @sysproperties.each do |key, value|
                file << property_string(key, value) + "\n"
            end
        end

        # Compute which system properties need to be set manually.  This, as it turns out, is a bad idea: the
        # Eclipse plugin for TC development (actually JUnit which it extends) creates an Eclipse launch
        # configuration and it needs ALL the properties since this configuration is reused.  Commented out in
        # case someone really wants to look at this, instead of just removing it.
        #required_system_properties = @sysproperties.keys & NON_CLASSPATH_LOADABLE_SYSTEM_PROPERTIES
        required_system_properties = @sysproperties.keys

        # Write out a file 'stamping' the module and subtree we've prepared this for, plus containing
        # extra information that the Eclipse tool we wrote that runs Terracotta tests needs in order
        # to correctly spawn the JVM that will run the test(s).
        File.open(@build_results.prepped_stamp_file(@subtree.build_module.module_set).to_s, "w") do |file|
            file << "# This file is an indication that 'tcbuild check_prep' has been run.\n"
            file << "tcbuild.prepared.module=#{@subtree.build_module.name.escape}\n"
            file << "tcbuild.prepared.subtree=#{@subtree.name.escape}\n"
            file << "tcbuild.prepared.cwd=#{@cwd.escape}\n"
            file << "tcbuild.prepared.jvm.java=#{tests_jvm.java.escape}\n"
            file << "tcbuild.prepared.jvm.version=#{tests_jvm.actual_version.escape}\n"
            file << "tcbuild.prepared.jvm.type=#{tests_jvm.actual_type.escape}\n"

            jvm_args = all_jvmargs
            if container_home = @subtree.container_home || @config_source['tc.tests.configuration.appserver.home']
              jvm_args << "-D#{@subtree.create_dynamic_property('appserver.home', container_home)}"
            end
            file << "tcbuild.prepared.jvmargs=#{jvm_args.length}\n"

            index = 0
            jvm_args.each do |jvmarg|
                file << "tcbuild.prepared.jvmarg_%d=#{jvmarg.escape}\n" % [ index ]
                index += 1
            end


            required_system_properties.each do |syspropertykey|
                file << "tcbuild.prepared.system-property.#{property_string(syspropertykey, @sysproperties[syspropertykey])}\n"
            end
        end

        puts "========================================================================"
        puts "Wrote required system properties for module #{@subtree.module_subtree_name} to:"
        puts "  '#{test_config_system_properties_file}'."
        puts "The test configuration system will automatically load this file as needed."

        extra = ""
        extra += "  JVM arguments:\n\n"

        unless all_jvmargs.empty?
            all_jvmargs.each { |key| extra += "#{key}\n" }
        end

        unless required_system_properties.empty?
            required_system_properties.each { |key| extra += "-D#{property_string(key, @sysproperties[key])}\n" }
        end

        unless extra.blank?
            puts ""
            puts :warn, "This tree requires certain arguments and system properties that "
            puts :warn, "can't be set at runtime. You should set these directly via your "
            puts :warn, "IDE. If you don't, your tests may or may not work -- you have "
            puts :warn, "been warned."
            puts ""
            puts extra
        end

        puts ""
        puts "And, just FYI (it isn't usually necessary to set these) the buildsystem "
        puts "normally runs tests in #{@subtree.module_subtree_name}..."
        puts "   ...with the current working directory set to:\n\n#{@cwd}\n\n"
        puts "   ...using the Java command at '#{tests_jvm.java}'."
        puts ""
    end

    @@next_failure_property_sequence = 1

    # Runs the tests. script_results is the ScriptResults object, which we inform of any
    # failures we run into.
    def run(script_results)
        raise "You must call setUp before running this method." unless @setUp

        return unless @has_tests

        puts ""
        puts "========================================================================"
        puts "RUNNING tests (#{@test_patterns.join(', ')}) on #{@subtree.module_subtree_name}..."
        puts ""

        failed = false
        failure_properties = [ ]

        # Run the tests. Most of the real magic here comes in the 'splice_into_ant_junit'
        # method, which puts the necessary <jvmarg>, <sysproperty>, and so forth elements
        # into the junit task.

        @ant.junit(
        :printsummary => "yes",
        :maxmemory => "512m",
        :timeout => @timeout,
        :dir => @cwd.to_s,
        :tempdir => @testrun_results.ant_temp_dir(@subtree).to_s,
        :fork => true,
        :showoutput => true,
        :jvm => tests_jvm.java.to_s) {
            splice_into_ant_junit

            # formatter that outputs result to console
            @ant.formatter(:type => "xml")
            @ant.formatter(:classname => 'com.tc.test.TCJUnitFormatter', :usefile => false)

            # Create a <batchtest> element for each pattern we have.
            @test_patterns.each do |pattern|
                failure_property_name = "tests_failed_%d" % @@next_failure_property_sequence
                @@next_failure_property_sequence += 1
                failure_properties << failure_property_name

                @ant.batchtest(:todir => @testrun_results.results_dir(@subtree).to_s, :fork => true, :failureproperty => failure_property_name) {
                  # formatter that out put JUnit XML result file
                  #@ant.formatter(:classname => 'com.tc.test.TCXMLJUnitFormatter', :usefile => false)
                  @ant.fileset(:dir => @build_results.classes_directory(@subtree).to_s, :includes => "**/#{pattern}.class")
                }
            end
        }

        # Check the failures by looking for the properies we set under failure_property_name, above.
        failure_properties.each { |property_name| failed = failed || (@ant.get_ant_property(property_name) != nil) }
        script_results.failed("Execution of tests in subtree '#{@subtree.module_subtree_name}' failed.") if failed

        # Aggregate the results into the aggregation directory, if it's set.
        unless @aggregation_directory.nil?
            puts "Copying test result files to '#{@aggregation_directory}'..."
            @ant.copy(:todir => @aggregation_directory.to_s) {
                @ant.fileset(:dir => @testrun_results.results_dir(@subtree).to_s, :includes => '*.xml')
            }

            Dir.open(@aggregation_directory.to_s).each do | file |

                next if File.size(FilePath.new(@aggregation_directory.to_s, file).to_s) > 0
                next unless file =~ /\.xml$/
                classname = file.scan(/TEST-(.+)\.xml/).join("")

                content = <<END
<?xml version="1.0" encoding="UTF-8" ?>
<testsuite errors="1" failures="0" name="#{classname}" tests="1" time="69">
  <properties>
    <property name="unknow" value="none"></property>
  </properties>
  <testcase classname="#{classname}" name="test" time="69"></testcase>
  <system-out/>
  <system-err><![CDATA[Test #{classname} failed. JVM crashed. Error parsing XML: Premature end of file.]]></system-err>
</testsuite>
END

                File.open(FilePath.new(@aggregation_directory.to_s, file).to_s, "w")  do | f |
                    f << content
                end
            end
        end
    end

    # Call this when you're all done with tests. It doesn't do anything yet, but it well may in the future.
    def tearDown
      # nothing yet
    end

    # Prints out the arguments and system properties we'd use when running tests on this tree.
    # This can be useful if you want to do something like run the test manually from the
    # command line (e.g., by invoking 'java' directly).
    def dump
        out = "\n\n========================================================================\n"
        out += "When running tests on subtree #{@subtree.module_subtree_name}, the buildsystem will use the following:\n\n"
        out += "  JVM arguments:               #{all_jvmargs.empty? ? '<none>' : all_jvmargs.join(' ')}\n"

        if @sysproperties.empty?
            out += "  System properties:           <none>\n"
        else
            out += "  System properties:           \n"
            @sysproperties.each { |key, value| out += "          -D#{property_string(key, value)}\n" }
        end

        out += "  Timeout:                     #{@timeout} milliseconds\n"
        out += "  Current working directory:   #{@cwd}\n"
        out += "  'java' command:              #{tests_jvm.java}\n\n"
        out += "  CLASSPATH:\n\n#{@classpath}\n\n"

        out
    end

    def get_compatible_vm(appserver)
      Registry[:appserver_compatibility].keys.each do |k|
        if appserver =~ Regexp.new(k)
          return Registry[:appserver_compatibility][k]
        end
      end
      nil
    end


    # Which JVM should we use for this set of tests?
    def tests_jvm(jvm_set = Registry[:jvm_set])
      return @jvm if @jvm

      candidate_source = "[unknown]"

      if candidate = jvm_set['tests-jdk']
        candidate_jvm = candidate
        candidate_source = "'tests-jdk' config override"
      elsif candidate = jvm_set['jdk']
        candidate_jvm = candidate
        candidate_source = "'jdk' config override"
      elsif candidate_name = @buildconfig['tests-jdk']
        candidate_source = "'tests-jdk' override from subtree buildconfig [#{candidate_name}]"
        candidate_jvm = get_required_jvm(candidate_name, candidate_source)
      elsif candidate_name = @buildconfig['jdk']
        candidate_source = "'jdk' override from subtree buildconfig [#{candidate_name}]"
        candidate_jvm = get_required_jvm(candidate_name, candidate_source)
      end

      if candidate_jvm
        override = true
      else
        candidate_jvm = @build_module.jdk
        candidate_source = "modules.def.yml entry for module"
        override = false
      end

      if requires_container?
        current_appserver = Registry[:appserver]
        compatibility = get_compatible_vm(current_appserver) || {
          'min_version' => JavaVersion::JAVA_MIN_VERSION,
          'max_version' => JavaVersion::JAVA_MAX_VERSION
        }
        min_version = JavaVersion.new(compatibility['min_version'])
        max_version = JavaVersion.new(compatibility['max_version'])
        if candidate_jvm.version < min_version || candidate_jvm.version > max_version
          if override
            jvm_version_mismatch(candidate_jvm, candidate_source,
                                 "appserver #{Registry[:appserver]}",
                                 compatibility)
          else
            if appserver_candidate_jvm = jvm_set.find_jvm(
                  :min_version => compatibility['min_version'],
                  :max_version => compatibility['max_version'])
              candidate_jvm = appserver_candidate_jvm
              candidate_source = "appservers.yml entry for #{current_appserver}"
            else
              raise(JvmVersionMismatchException,
                    "Could not find JDK compatible with #{Registry[:appserver]},\n" +
                    "which requires minimum version #{min_version} and maximum " +
                    "version #{max_version}")
            end
          end
        end
      end

      if candidate_jvm.version < @build_module.jdk.min_version
        jvm_version_mismatch(candidate_jvm, candidate_source,
                              "module #{@build_module.name}",
                              {
                                'min_version' => @build_module.jdk.min_version,
                                'max_version' => @build_module.jdk.max_version
                              })
      else
        puts("JDK version #{candidate_jvm.version} is compatible with module " +
             "#{@build_module.name}, which has minimum version #{@build_module.jdk.min_version}")
      end
      puts("Using JDK #{candidate_jvm} from source #{candidate_source}")
      @jvm = candidate_jvm
    end

  private

    def add_debug_jvmargs
      if debug_port = @config_source['debug']
        unless Integer(debug_port) > 0
          raise "debug argument must be an integer"
        end

        common_options = "server=y,transport=dt_socket,suspend=y,address=#{debug_port}"
        version = tests_jvm.version
        if version >= "1.5.0"
          # Note: this works for IBM JDK too
          @extra_jvmargs << "-agentlib:jdwp=#{common_options}"
        elsif version >= "1.4.0"
          @extra_jvmargs << "-Xdebug"
          @extra_jvmargs << "-Xrunjdwp:#{common_options}"
        end
      end
    end

    def jvm_version_mismatch(candidate_jvm, candidate_source, thing, compatibility)
      raise(JvmVersionMismatchException,
            "\nActive JDK #{candidate_jvm}\nfrom source #{candidate_source}\n" +
            "is incompatible with #{thing} which requires minimum version " +
            "#{compatibility['min_version']} and maximum version " +
            "#{compatibility['max_version']}")
    end

    def get_required_jvm(name, source)
      jvm = Registry[:jvm_set][name]
      raise("The JDK '#{name}' (from source #{source}) does not exist") unless jvm
      jvm
    end

    # Splice the appropriate elements (CLASSPATH, JVM arguments, system properties,
    # and so on) into Ant.
    def splice_into_ant_junit
        @ant.classpath {
            @ant.pathelement(:path => @classpath.to_s)
        }

        @jvmargs.each do |jvmarg|
            @ant.jvmarg(:value => jvmarg)
        end

        @sysproperties.each do |key, value|
            @ant.sysproperty(:key => key, :value => value)
        end

        @extra_jvmargs.each do |jvmarg|
            @ant.jvmarg(:value => jvmarg)
        end
    end

    # A description of the patterns we're going to run tests with.
    def patterns_description
        out = ""
        @test_patterns.each do |pattern|
            out += ", " unless out.blank?
            out += "'" + pattern + "'"
        end
        out
    end

    # Figure out which tests we're going to run, as a PathSet.
    def find_tests
        @subtree.classes_matching_patterns(@test_patterns, @ant, @platform, @build_results)
    end

    # The message we write into the 'did-not-run' XML file.
    NOT_RUN_MESSAGE = 'This test, \'%s\', DID NOT RUN. Some problem (i.e. classloader, bootjar, etc) prevents it from starting. Please check the log for error message. '

    # The set of cached Java system properties.
    $cachedJavaProperties = nil

    # Returns a (possibly cached) set of all Java system properties, as a hash. (Caching is
    # safe, because we don't ever set Java system properties from our code.)
    def all_java_properties
        if $cachedJavaProperties.nil?
            $cachedJavaProperties = { }
            iterator = JavaSystem.getProperties.entrySet.iterator
            while iterator.hasNext
                entry = iterator.next
                $cachedJavaProperties[entry.getKey] = entry.getValue
            end
        end

        $cachedJavaProperties
    end

    # Creates a 'did-not-run' XML file for the test with the given class name, and put it in the
    # given target file. This is overwritten by the test once it completes (whether it fails or
    # succeeds); we write it out so that we can make sure we catch the case where the test never
    # completes.
    def create_did_not_run_file(class_name, target_file)
        File.open(target_file.to_s, "w") do |file|
            file << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
            file << "<testsuite errors=\"0\" failures=\"1\" name=\"#{class_name.escape(:xml_attribute)}\" tests=\"0\" time=\"0.000\">\n"
            file << "<testcase classname=\"#{class_name.xml_escape}\" name='test' time='0.0'>\n"
            file << ("  <failure type='junit.framework.AssertionFailedError' message=\"" + NOT_RUN_MESSAGE + "\">\n") % class_name.xml_escape(true)
            file << ("      " + NOT_RUN_MESSAGE + "\n") % class_name.xml_escape
            file << "   </failure>\n"
            file << "</testcase>\n"
            file << "<system-out/><system-err/>\n"
            file << "</testsuite>\n"
        end
    end

    # What JVM arguments should we use for these tests?
    def all_jvmargs
        out = @jvmargs || [ ]
        out += @extra_jvmargs unless @extra_jvmargs.empty?
        out
    end

    # do a "ps auxwwww | grep java"
    # to be used in monkey environment ONLY
    def ps_grep_java
        java_processes = case @build_environment.os_type(:nice)
            when /windows/i: Registry[:platform].exec("#{Registry[:basedir]}/common/lib.tests.base.native/Windows/pv.exe", "-l", "java.exe")
            when /solaris/i: `/usr/ucb/ps auxwwww | grep java | grep -v grep`
            else `ps auxwwww | grep java | grep -v grep`
        end
        java_processes
    end
end
